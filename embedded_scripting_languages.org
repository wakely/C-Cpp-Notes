#+INCLUDE: theme/style.org 
#+TITLE: Embedded Scripting Languages
#+DESCRIPTION: cpp/c++ embedded scripting languages survey 
#+STARTUP: content 

* Embedded Scripting Languages 
** Overview 

  *Reasonable Features of Embedded Scripting Languages*

This section lsits some reasonable features that a language designed
to be embedded should have:

   + _Ligthweight_ -  Small footprint, small size and memory requirements. 

   + _Scripting Engine as a library_:
     + Must be available as C or C++ library which exposes the
       interpreter API allowing the client code to evaluate scripting
       code from strings or files and also to retrieve objects from the
       virtual machine memory.

   + _Sandboxing or capability limitations_
     + A reasonable requirement for an embedded scripting language is
       limiting the capabilities and APIs which can be used possibly
       allowing the execution of non-trusted scripts. Example: the
       Javascript engines of most web browsers do not allow the script
       to interact with file systems or operating system APIs.

   + _Permissive License for static linking_ 

   + _Use Cases_
     + DSL - Domain Specific Languages 
     + Game Engines 
     + Configuration files => Data Description language. 
     + User content
     + Allow application runtime changes without recompilation.
     + User extension without modification of source code. 

 *Examples of embedded scripting languages usage and use-cases*

     * TCL - Tool Command Language => Used by many EDA - Electronic
       Design Automation Sofware in electronic engineering.

     * JavaScript => Used in Web Browsers, which are written mostly in
       C++, for controlling user interaction, animation and etc. 

     * TinyScheme => Used by GNU GIMP drawing application ans Apple's
       MacOSX sandbox configuration. 

     * Lua language => Used by many game engines and also by
       applications such as: Nginx web server; Linux Conky; Geany
       Editor; NMap editor and so on.

     * Squirrel Language => Used in game engines

     * Python
       + => Python is used as embedded scripting language by GDB - GNU
         Debugger ; WinDBG  - Windows Debugger; IDA - Debugger for
         Reverse Engineering.
       + Disadvantages: Python has a large footprint; it was not
         designed as an embedded scripting language and it is not
         possible to forbid the interpreter from calling file system
         and process creation APIs.

     * AutoLisp [proprietary] => Lisp-like language used in Autocad.

     * SQL (Structured Query Language) => Many databases are
       implemented in C or C++ uses SQL as scripting language and
       domain specific language (DSL) for querying and storing
       data. Example: SQLite, Postgres SQL, ...

     * Emacs Lisp => Emacs core, including the LISP
       engine/interpreter, is written in C and other parts are
       written in Emacs Lisp. This lisp dialect allows extending Emacs
       at with custom extensions (plugins) and also modifying the
       application behavior at runtime.

     * VBA - Visual Basic for Application [proprietary] => Used in
       Microsft Office Suite, specially in Microsft Excel.

 *Considerations for choosing embedded scripting languages*

  * Small footprint and small overhead

  * Stability of C or C++ API 

  * C++ API bindings

  * Permissive license for static linking or option of dual license
    for static linking. 

  * Documentation and of C or C++ binding APIs, examples about binding
    code

  * Garbage collector implementation 

  * Heavy duty computations with significant overhead should be
    performed on the C++-side, specially loops.

  * JIT - Just-In-Time compiler => can increase the performance by
    translating bytecodes into machine code.
    + Example: Lua JIT, Javascript V8 engine used by Chrome browser.

  * Features for running untrusted scripts or configuration: 

    * Ability for restricting capabilities such as creating process,
      accessing the file system and so on.

    * Non-turing complete => better for configuration 

  * Familiarity of the targe audience

    * Lua is pervasive in Games

    * TCL is pervasive on Electronic Design Automation Software 

    * Javascript is widely used on the Web, NodeJS and also as
      embedded scripting language of web browsers. 

 *Further Reading* 
 
  + [[https://accu.org/index.php/journals/351][ACCU - Embedded Scripting Languages]]

  + [[https://github.com/dbohdan/embedded-scripting-languages][GitHub - dbohdan/embedded-scripting-languages: A list of embedded scripting languages]]

  + [[https://articles.emptycrate.com/2016/03/26/so-you-want-to-embed-a-scripting-language.html][EmptyCrate.com: So You Want to Embed A Scripting Language in Your Application]]

  + [[https://softwareengineering.stackexchange.com/questions/403911/what-makes-a-scripting-language-embeddable][What makes a scripting language "embeddable"? - Software Engineering Stack Exchange]]

** Embedded Scripting Languages
 
 *Selection of embedded scripting languages and engines available as  libraries*

Non categorized: 

  * [[http://tcl-lang.org/][TCL]] - Tool Command Language
    * License: akin to BSD
    * Implementation: C
    * Syntax Type: N/A
    * Note: pervasive in EDA - Electronic Design Automation software.
    * See:
      * [[https://wiki.tcl-lang.org/page/How+to+embed+Tcl+in+C+applications][How to embed Tcl in C applications]]

  * [[https://github.com/mruby/mruby][mruby]] (Embeddable Ruby implementation)
    * License: BSD
    * Implementation: C
    * Syntax type: Ruby

  * [[https://github.com/munificent/wren][Wren]]
    * License: MIT
    * Implementation: C
    * Syntax Type: N/A 

  * [[https://www.jinx-lang.org/][Jinx]]
    * License: MIT
    * Implementation: C++17
    * Syntax Type: N/A

  * [[https://marcobambini.github.io/gravity][Gravity]]
    * License: -
    * Implementation: C
    * Syntax type: Apple's SWIFT language

  * [[https://github.com/GaijinEntertainment/daScript][DaScript]] 
    * License: - 
    * Implementation: C++14
    * Syntax type: Akin to Python

Lua or similar to Lua (mimics Lua syntax)

  * [[http://lua.org/][Lua]]
    * License: MIT
    * Implementation: C
    * Syntax Type: syntax inspired by scheme.

  * [[http://luajit.org/][LuaJIT]] (Lua with JIT - Just-in-Time compiler which translates
    bytecodes to native machine code for better performance.)
    * License: MIT
    * Implementation: C
    * Syntax type:  lua 

  * [[http://www.gmscript.com/][GameMonkey Script]]
    * License: MIT 
    * Implementation: C++
    * Syntax type: Akin to Lua

  * [[http://squirrel-lang.org/][Squirrel]]
    * License: MIT
    * Implementation: C++
    * Syntax type:    Lua-like
    * Note: Despite be implemented in C++, does not expose a C++ API,
      it exposes a C API. 

  * [[https://github.com/mingodad/squilu][Squilu]] (Squirrel fork)
    * License: MIT
    * Implementation: C++
    * Syntax type: Lua-like 

Similar to C++ (syntax that mimics C++)

  * [[http://www.angelcode.com/angelscript/][AngelScript]]  (Note: statically typed)
    * License: Zlib
    * Implementation: C++ 
    * Syntax type: C++-like

  * [[http://chaiscript.com/][ChaiScript]] 
    * License: BSD 
    * Implementation: C++
    * Syntax type: C++-like

Smiliar to Javascript or subset of Javascript (ECMAScript)

  * [[http://duktape.org/][Duktape]]
    * License: MIT
    * Implementation: C
    * Syntax type: Javascript (aka ECMAScript) E5/E5.1

  * [[https://github.com/espruino/Espruino][Espruino]]
    * License: MPL 2       
    * Implementation: C
    * Syntax type: ES5 - Javascript (ECMaScript)

  * [[https://github.com/jerryscript-project/jerryscript][JerryScript]]
    * License: Apache v2
    * Implementation: C
    * Syntax type: Javascript (ECMAScript)

Similar to Lisp or Scheme: 

  * [[http://tinyscheme.sourceforge.net/][TinyScheme]]
    * License: BSD 
    * Implementation: C
    * Syntax tyope: scheme, lisp
    * Note: Used in GNU GIMP as scripting language and Apple MacOSX's
      sandbox as configuration language.

  * [[https://ccrma.stanford.edu/software/snd/snd/s7.html][S7 Scheme]] (Variant of TinyScheme)
    * License: BSD
    * Implementation: C
    * Syntax type: C 

  * [[https://github.com/ashinn/chibi-scheme][Chibi Scheme]]
    + Implementation: C
    + Syntax type:   Scheme, Lisp 

  * [[https://github.com/SuperFola/Ark][ArkScript]]  
    + License: MPL license
    + Implementation: C
    + Syntax type:    Lisp-like

  * [[https://gitlab.com/embeddable-common-lisp/ecl][ECL - Embeddable Common Lisp]]
    * License: LGPL - 2
    * Implementation: C
    * Syntax type:    Lisp, Common Lisp
    * Note: LGPL allows dynamically linking of closed source
      applications, but static linking requires source code disclosure
      and release under the same license. Some LGPL libraries, such as
      QT, allows static linking via commercial license.
 
** MuParser - Math expression parser 

MuParser is a non-turing complete embedded scripting engine for
evaluating math expressions. 

Web Site: 
 + https://beltoforion.de/article.php?a=muparser

Repository: 
 + https://github.com/beltoforion/muparser/

Conan Reference: 
 + [[https://bintray.com/conan-community/conan/muparser%253Aconan/2.2.6%253Astable][muparser/2.2.6@conan/stable]]

 *Sample Project*

File: *CMakeLists.txt*

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)
  project(cppexperiments)

  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_VERBOSE_MAKEFILE ON)

  # ============= Conan Bootstrap =============================#

  # Download automatically, you can also just copy the conan.cmake file
  if(NOT EXISTS "${CMAKE_BINARY_DIR}/conan.cmake")
     message(STATUS "Downloading conan.cmake from https://github.com/conan-io/cmake-conan")
     file(DOWNLOAD "https://github.com/conan-io/cmake-conan/raw/v0.13/conan.cmake"
                   "${CMAKE_BINARY_DIR}/conan.cmake")
  endif()

  include(${CMAKE_BINARY_DIR}/conan.cmake)

  # Possible values "default" and "llvm8"
  set(CONAN_PROFILE default)

  conan_cmake_run(REQUIRES
                  muparser/2.2.6@conan/stable
                  BASIC_SETUP
                  BUILD missing)

   #======= Targets Settings ===============+#

  add_executable(muparser1_formula muparser1_formula.cpp)
  target_link_libraries(muparser1_formula muparser)
#+END_SRC

File: *muparser1_formula.cpp*

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string>
  #include <cmath>

  #include <muParser.h>

  // Defined for UNIX-like: Linux, Mac OSX, QNX, ...
  #if __unix__
    #include <unistd.h>
  #endif

  bool isTTY_terminal()
  {
     #if __unix__
        return ::ttyname(STDIN_FILENO) != nullptr;
     #else
        return false;
     #endif
  }

  double future_value(double PV, double rate, double nper)
  {
      return PV * std::pow(1 + rate / 100.0, nper);
  }

  int main()
  {

      mu::Parser p1;

      std::puts("\n====== EXPERIMENT 1 - Simple math expression =======");
      p1.SetExpr("2^1 + 2^3 + 2^4");
      std::cout << " [*] p1-A value: "
                << p1.GetExpr() << " = " << p1.Eval() << std::endl;

      p1.SetExpr("3.5 * 10 - sin(3.1415) * 2.0 + sqrt(10) / 100.0 + 2^3");
      std::cout << " [*] p1-B value: "
                << p1.GetExpr() << " = " << p1.Eval() << std::endl;

      std::puts("\n====== EXPERIMENT 2 - Expression with variables =======");
      p1.DefineConst("pi", 3.1415);
      double x = 10.0, y = 4.5;
      p1.DefineVar("x", &x);
      p1.DefineVar("y", &y);
      p1.SetExpr(" 3 * pi + sin(pi) + 4 * x + y - 5");
      std::cout << " [*] p1-C value: "
                << p1.GetExpr() << " = " << p1.Eval() << std::endl;

      std::puts("\n====== EXPERIMENT 3 - Expression with custom function =======");

      p1.DefineFun("fv", &future_value);

      p1.DefineFun("payoff", [](double S, double K){
          return std::max(S - K, 0.0);
      });

      p1.SetExpr("fv(100, 2, 8) + payoff(100, 90)");
      std::cout << " [*] p1-D value: " << p1.GetExpr() << " = " << p1.Eval() << std::endl;


      std::puts("\n====== EXPERIMENT 4 - Parser error handling =======");

      // When an error happens it throws an exception: mu::ParserError
      try{
          p1.SetExpr("10.2 * 5.0 + a * 3");
          double value = p1.Eval();
          std::cout << " [*] p1-E value: " << value << std::endl;
      } catch (mu::ParserError const& ex)
      {
          std::cerr << " [ERROR] p1-C Parser error: " << ex.GetMsg() << std::endl;
      }


      std::puts("\n====== EXPERIMENT 5 - Calutor Interactive Shell ======");

      if(isTTY_terminal())
      {
          std::cout << " === Calculator Started OK. =====" << std::endl;

          mu::Parser p2;
          double ans = 0.0;
          p2.DefineVar("ans", &ans);
          std::string line;

          while(std::cin.good())
          {
              std::cout << " EXPR => ";
              std::getline(std::cin, line);

              if(line == "")
                  continue;

              if(line == "quit")
                  break;

              p2.SetExpr(line);
              try {
                  ans = p2.Eval();
                  std::cout << " => ans = " << ans << "\n\n";
              } catch(mu::ParserError const& ex)
              {
                  std::cerr << " [ERROR] Parser error " << ex.GetMsg() << std::endl;
              }
          }

      }

  #if _WIN32
      std::cout << "Enter RETURN to exit. " << std::endl;
      std::cin.get();
  #endif
      return 0;
  }
#+END_SRC

 *Program output:*

#+BEGIN_SRC sh 
   $ ./muparser1_formula 

   ====== EXPERIMENT 1 - Simple math expression =======
    [*] p1-A value: 2^1 + 2^3 + 2^4  = 26
    [*] p1-B value: 3.5 * 10 - sin(3.1415) * 2.0 + sqrt(10) / 100.0 + 2^3  = 43.0314

   ====== EXPERIMENT 2 - Expression with variables =======
    [*] p1-C value:  3 * pi + sin(pi) + 4 * x + y - 5  = 48.9246

   ====== EXPERIMENT 3 - Expression with custom function =======
    [*] p1-D value: fv(100, 2, 8) + payoff(100, 90)  = 127.166

   ====== EXPERIMENT 4 - Parser error handling =======
    [ERROR] p1-C Parser error: Unexpected token "a" found at position 13.

   ====== EXPERIMENT 5 - Calutor Interactive Shell ======
    === Calculator Started OK. =====
    EXPR => 9.81 * sin(3.1415 / 2.0) + 100 * sqrt(285.6) + exp(3.65)
    => ans = 1738.26

    EXPR => ans / 100.0 - 80.0
    => ans = -62.6174

    EXPR => ans * ans
    => ans = 3920.94

    EXPR => 

#+END_SRC

** Lua scripting engine 
*** Overview 

Lua (moon in Portuguese) is a ligthweight multi paradigm scripting
language written in C. Due to Lua be available as small footprint
libraryn this language is widely used as embedded scripting by many
applications for scripting and as configuration or data description
language.

Use cases: 

  + Scripting for C or C++ applications

  + Extension language => Add new functionality and updates without
    recompilation. 

  + Provide interactive REPL or shell to C or C++ applications.

  + Program configuration (settings)

  + Data description language 

Some applications which uses Lua: 

  + NMap network scanner 
  + MediaWiki (engine used by Wikipedia)
  + Nginx Web Server
  + Redis Database 
  + Linux Conky 
  + Geany text editor
  + LuaTex
  + NetBSD
  + Cheat Engine
  + Lots of games ... ...
  + ... ... 

 *Repository and  C++ Binding Libraries* 

  * Official Repository Mirror
    + https://github.com/lua/lua

  * Lua Bind
    + https://www.rasterbar.com/products/luabind/docs.html
    + https://sourceforge.net/projects/luabind/
    + https://github.com/luabind/luabind 

  * Sol2 (means 'sun' 2 in Portuguese)
    + https://github.com/ThePhD/sol2
    + https://sol2.readthedocs.io/en/latest/

 *Articles* 

General: 
 
  + [[https://www.lua.org/manual/5.1/manual.html][Lua 5.1 Reference Manual]] - Documentation 

  + [[https://en.wikipedia.org/wiki/Lua_(programming_language)][Lua (programming language) - Wikipedia]]

  + [[https://en.wikipedia.org/wiki/List_of_applications_using_Lua][List of applications using Lua - Wikipedia]]

  + [[https://en.wikipedia.org/wiki/Category:Lua-scripted_video_games][Category:Lua-scripted video games - Wikipedia]]

  + [[http://www.godpatterns.com/2005/07/using-lua-scripting-for-games.html][Godpatterns: Using Lua Scripting For Games]]

  + [[https://gamedev.stackexchange.com/questions/73728/how-does-lua-work-as-a-scripting-language-in-games][c++ - How does Lua work as a scripting language in games? - Game Development Stack Exchange]]

  + [[https://steamcommunity.com/sharedfiles/filedetails/?id=398177770][Steam Community - Guide - GameGuru LUA scripting summary and guide.]]

  + [[https://www.nginx.com/resources/wiki/modules/lua/][Lua on NGINX web server]]

  + [[https://blog.cloudflare.com/pushing-nginx-to-its-limit-with-lua/][Pushing Nginx to its limit with Lua]] - CloudFlare 

  + [[https://nmap.org/book/nse-language.html][Script Language | Nmap Network Scanning]]
    + "The core of the Nmap Scripting Engine *is an embeddable Lua*
      *interpreter*. _Lua is a lightweight language designed for_
      _extensibility. It offers a powerful and well-documented API for_
      interfacing with other software such as Nmap. The second part of
      _the Nmap Scripting Engine is the NSE Library, which connects Lua_
      _and Nmap_. This layer handles issues such as initialization of
      the Lua interpreter, scheduling of parallel script execution,
      script retrieval and more. It is also the heart of the NSE
      network I/O framework and the exception handling mechanism. It
      also includes utility libraries to make scripts more powerful
      and convenient. The utility library modules and extensions are
      described in the section called 'NSE Libraries'."

  + [[https://github.com/nmap/nmap/tree/master/nselib][Nmap Scripting Engine Source Code]] / GITHUB

  + [[https://dev.to/citizen428/extending-nmap-withlua-bpa][Extending Nmap With Lua - DEV]]

Lua C API: 

  + [[https://www.lua.org/pil/24.1.html][Programming in Lua : 24.1]] 

  + [[http://lua-users.org/wiki/BindingCodeToLua][lua-users wiki: Binding Code To Lua]] 

  + [[http://lua-users.org/wiki/SimpleLuaApiExample][lua-users wiki: Simple Lua Api Example]]

  + [[http://webserver2.tecgraf.puc-rio.br/lua/local/pil/24.html][Programming in Lua : 24]]

  + [[https://chsasank.github.io/lua-c-wrapping.html][Exposing C functions to Lua]]
*** Example project with Sol2 C++ binding library 

This sample project builds a C++ statically linked executable
embedding the Lua scripting engine using the Sol2 binding library,
which is header only. Neither Sol2 nor Lua libraries need to be
installed before building this sample project as the CMake scripts
take care of downloading and building all dependencies.

Lua repostiory mirror: 

  + https://github.com/lua/lua

Sol2 library repository: 

  + https://github.com/ThePhD/sol2

Sol2 library documentation: 
 
  + https://sol2.readthedocs.io/en/latest/

  *Files* 

File: CMakeLists.txt 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.0)
  project(duktape-cc-trial)

  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_VERBOSE_MAKEFILE ON)

  include(lua-lib.cmake)

  #-----  Target Definitions ----------------------------#

         add_executable( embed-lua-sol embed-lua-sol.cpp)
  target_link_libraries( embed-lua-sol lua::lualib )

  # Lua REPL executable built from static library liblua.a (Linux)
  # Note: the main() function is in the file main.c in the lua sources directory
         add_executable( lua-repl $<TARGET_OBJECTS:lua::lualib> )
  target_link_libraries( lua-repl m pthread )
#+END_SRC

File: lua-lib.cmake 

  + CMake Script for downloading sol2 binding library and lua library
    sources. 

#+BEGIN_SRC cmake 
   include(FetchContent)

   # Note: the 'add_subriectory' line was commented becuyase 
   #       library that will be downloaded does not have 
   #       a CMakeListst.txt file at the root directory. 
   macro(Download_Library_Git  NAME TAG REPOSITORY_URL)
       FetchContent_Declare(
           ${NAME}
           GIT_REPOSITORY  ${REPOSITORY_URL}
           GIT_TAG         ${TAG}
       )
       FetchContent_GetProperties(${NAME})
       if(NOT cpputest_POPULATED)
           FetchContent_Populate(${NAME})
           message("${NAME}_SOURCE_DIR} = ${${NAME}_SOURCE_DIR}")        

           # => Disable following line: the library does not have a CMakeLists.txt
           #    at the root directory.
           # add_subdirectory(${${NAME}_SOURCE_DIR} ${${NAME}_BINARY_DIR})
       endif()
   endmacro()


   # ====>> Download Lua library <<==========================#

   Download_Library_Git( lua                       
                         v5.3.5
                         https://github.com/lua/lua
                       )

   file(GLOB_RECURSE lua_sources "${lua_SOURCE_DIR}/*.c")
   file(GLOB_RECURSE lua_headers" ${lua_SOURCE_DIR}/*.h")

   message( [TRACE] " lua_SOURCE_DIR = ${lua_SOURCE_DIR} ")

                  add_library( lua STATIC ${lua_sources} ${lua_headers} )
   target_include_directories( lua PUBLIC ${lua_SOURCE_DIR} )

   add_library( lua::lualib  ALIAS lua)

   # ====>> Download Sol C++ binding library <<====================#

   FetchContent_Declare( sol2 
                         GIT_REPOSITORY  https://github.com/ThePhD/sol2
                         GIT_TAG         v3.2.0
                       )

   FetchContent_MakeAvailable( sol2 )
   include_directories( ${sol2_SOURCE_DIR}/include )
#+END_SRC

File: embed-lua-sol.cpp 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string> 
  #include <vector> 
  #include <algorithm>

  #include <sol/sol.hpp>


  class Counter {
  private: 
      std::string m_name;
      int         m_counter;

  public: 

      // Ctor [1] => Default ctor 
      Counter(): Counter("untitled", 0) { }

      // Ctor [2]
      Counter(std::string name, int counter)
        : m_name{std::move(name)}, m_counter{counter}
      { 
          std::cout << " [TRACE] Counter created with =>  { " 
                    <<   " name = " << m_name 
                    << " ; counter = " << m_counter 
                    << " } \n";
      }

      int getCounter() const { return m_counter; }
      void setCounter(int n) {       
        m_counter = n; 
        std::cout << " [TRACE] I was set to value " << n << std::endl;
      }

      void increment() {       
        m_counter++; 
        std::cout << " [TRACE] increment event =>> counter = {  " 
                  << m_name << " ; " << m_counter 
                  << " } " << std::endl;
      }    
  };

  double add_fun(double a, double b)
  {
      std::cout << " [TRACE] addfun() => a = " << a 
                << " ; b = " << b << std::endl;
      return a + b;             
  }

  void sol_eval(sol::state& ctx, std::string code)
  {
      try {
          ctx.script( std::move(code) );        
      } catch ( sol::error const& ex) {
          std::cerr << " [SOL ERROR] " << ex.what() << "\n";
      }
  }


  int main()
  {
      // Create an instance of lua Engine (aka virtual Machine)
      sol::state ctx{};

      // Load basic libraries (such as print)
      ctx.open_libraries(sol::lib::base, sol::lib::coroutine, sol::lib::string, sol::lib::io);    

      // Register function pointer 
      ctx.set_function("add_fun", &add_fun);

      // Register lambda object 
      ctx.set_function("make_vector", [](int n ) -> std::vector<int> {
          auto vec = std::vector<int>(n);
          for(int i = 0; i < n; i++ ) vec[i]= i * 3;
          return vec;
      });

      // Set variables in the Lua engine 
      ctx["points"]    = 2000;
      ctx.set("character", "<Marcus Tulius Cicero>");

      /* ===========>>> E X P E  R I M E N T / 1  <<=========*/
      std::puts("\n [EXPERIMENT 1] ==>> Evaluating string as code ");
      {
          // ===>>> Eval code as string <<=== 
          // Throws exception sol::error 
          ctx.script(R"(
              print(" [LUA] Hello world lua "); 

              x = add_fun(10, 20);
              print("\n  [LUA] result =  " .. x);

              v = make_vector(5);
              print("\n  [LUA] Printing a vector ");

              for i = 1, 5 do 
                  print("   -> v[" .. i .. " ] = " .. v[i] );
              end 

              print("  [LUA] VAR points    = " .. points );
              print("  [LUA] VAR character = " .. character );
          )");

      }

      /* ===========>>> E X P E  R I M E N T / 2  <<=========*/
      std::puts("\n\n [EXPERIMENT 2] ==>> Reading configuration ");
      {
          ctx.script(R"(
              -- Simulation of user configuration from script     
              asset_path   = "C:\\\\Users\\myuser\\data\\files\\";
              user_credits = 2000;
              width        = 200.561;        
          )");

          auto asset_path = ctx.get<std::string>("asset_path");
          int user_credits = ctx["user_credits"];

          std::cout << "  [*] => asset_path = " << asset_path << "\n";
          std::cout << "  [*] => user_credits = " << user_credits << "\n";

      }

      /* ===========>>> E X P E  R I M E N T / 3  <<=========*/
      std::puts("\n\n [EXPERIMENT 3] ==>> Register C++ classes ");

      struct StatefulFunctor {
          int state = 0;
          StatefulFunctor(int state): state(state){ }
          int operator()(){ 

              std::cout << "  *=>> [StatefulFunctor] My new state is = " 
                        << this->state << "\n";
              return state++; 
          }
      };

      auto stateful = StatefulFunctor(10);
      ctx.set_function("stateful", stateful);

      ctx.script(R"(
          stateful();
          stateful();
          stateful();
      )");


      ctx.new_usertype<Counter>(
          // Class name 
           "Counter"          

          //  --- Register methods  ------ //
          ,"getCounter", &Counter::getCounter
          ,"setCounter", &Counter::setCounter
          ,"increment",  &Counter::increment

          // --- Register properties  ---- //
          , "value",     sol::property( &Counter::getCounter
                                      , &Counter::setCounter)
      );


      sol_eval(ctx, R"(
          print("\n ----->>> Calling C++ classes from Lua <----- ");

          -- Create new instance (object) of C++ class Counter 
          counter = Counter.new();
          counter:increment();
          counter:increment(); 
          counter:increment();

          x = counter:getCounter(); 
          print("  [*] value of counter is equal to = " .. x);

          counter.value = 2000;
          print(" [*] Counter value is equal to = " .. counter.value );
      )");

      Counter* ptr = ctx.get<Counter*>("counter");

      std::cout << " [FROM C++] counter value = " 
                << ptr->getCounter() 
                << "\n";

      return 0;
  }
#+END_SRC

Building: 

#+BEGIN_SRC sh 
   $ cmake -H. -B_build -DCMAKE_BUILD_TYPE=Debug
   $ cmake --build _build --target 
#+END_SRC

Check executable: 

#+BEGIN_SRC sh 
 # Confirm whether the executable is statically linked against LuaLib 
 $ ldd _build/embed-lua-sol 
	linux-vdso.so.1 (0x00007ffdf0fc4000)
	libstdc++.so.6 => /lib64/libstdc++.so.6 (0x00007fe4490e6000)
	libm.so.6 => /lib64/libm.so.6 (0x00007fe448fa0000)
	libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x00007fe448f85000)
	libc.so.6 => /lib64/libc.so.6 (0x00007fe448dbb000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fe4492fa000)

   # Static library 
   $ file _build/liblua.a 
  _build/liblua.a: current ar archive
#+END_SRC

Program output: 

#+BEGIN_SRC sh 
   $ _build/embed-lua-sol 

   [EXPERIMENT 1] ==>> Evaluating string as code 
   [LUA] Hello world lua 
   [TRACE] addfun() => a = 10 ; b = 20

    [LUA] result =  30.0

    [LUA] Printing a vector 
     -> v[1 ] = 0
     -> v[2 ] = 3
     -> v[3 ] = 6
     -> v[4 ] = 9
     -> v[5 ] = 12
    [LUA] VAR points    = 2000
    [LUA] VAR character = <Marcus Tulius Cicero>


   [EXPERIMENT 2] ==>> Reading configuration 
    [*] => asset_path = C:\\Users\myuser\data\files\
    [*] => user_credits = 2000


   [EXPERIMENT 3] ==>> Register C++ classes 
    *=>> [StatefulFunctor] My new state is = 10
    *=>> [StatefulFunctor] My new state is = 11
    *=>> [StatefulFunctor] My new state is = 12

   ----->>> Calling C++ classes from Lua <----- 
   [TRACE] Counter created with =>  {  name = untitled ; counter = 0 } 
   [TRACE] increment event =>> counter = {  untitled ; 1 } 
   [TRACE] increment event =>> counter = {  untitled ; 2 } 
   [TRACE] increment event =>> counter = {  untitled ; 3 } 
    [*] value of counter is equal to = 3
   [TRACE] I was set to value 2000
   [*] Counter value is equal to = 2000
   [FROM C++] counter value = 2000

#+END_SRC

Run Lua repl executable (defined in CMake): 

#+BEGIN_SRC lua 
   $ rlwrap  _build/lua-repl 
   Lua 5.3.5  Copyright (C) 1994-2018 Lua.org, PUC-Rio
   > 
   > 

   > print(" Hello world Lua / Luna / Moon REPL ")
    Hello world Lua / Luna / Moon REPL 

   > for i = 1, 5 do print(" i = " .. i ) end
    i = 1
    i = 2
    i = 3
    i = 4
    i = 5


   function myfunction(a, b) 
     return math.sin(a) * math.exp(b) / a - a * b 
   end 

   > myfunction(3.5, 2.0)
   -7.7405591279893

   function add (a)
      local sum = 0
      for i,v in ipairs(a) do
         sum = sum + v
      end
      return sum
   end

   > add({ 2.5, 10.2, -2.51, 8.251, 10.56})
   29.001

   function add (a)
         local sum = 0
         for i,v in ipairs(a) do
           sum = sum + v
         end
   return su
#+END_SRC

** Squirrel Scripting Language 
*** Overview 

   + Squirrel is a embedded scripting language, similar to Lua, but with
     C-like syntax, designed to be embedded in larger C or C++
     applications such as game engines. Squirrel is written in C++, but
     it only exposes a C API, which makes binding C++ code
     cumbersome. However, there are many libraries which simplifies the
     embedding of squirrel in C++ codebases.

 *Official Web Site*

   + http://www.squirrel-lang.org/

 *Official Repository* 

   + https://github.com/albertodemichelis/squirrel

 *Squirrel fork with a more C++-like syntax*

 + https://github.com/mingodad/squilu

 *Articles about squirrel language*

  + [[https://developer.electricimp.com/squirrel/squirrelcrib][Squirrel Programming Guide | Dev Center]]

  + [[https://www.ibm.com/developerworks/aix/library/au-spunix_squirrel/index.html][Speaking UNIX: The Squirrel portable shell and scripting language]]

  + http://wiki.ogre3d.org/Squirrel+Scripting+Language

 *Applications using Squirrel*

  * CodeBlocks IDE for C and C++

  * OpenTTD Game - http://www.openttd.org/en/

 
 *Libraries for simplifying embedding squirrel in C++ code* 
 
Libraries for simplifying squirrel embedding in C++ code (binding
C++ code):

     + *SQPlus*
       + http://wiki.squirrel-lang.org/default.aspx/SquirrelWiki/SqPlus.html

     + *SQrat*
       + http://scrat.sourceforge.net/

     + *Squal*
       + https://github.com/jonigata/squall

     + *SimpleSquirrel*
       + https://github.com/matusnovak/simplesquirrel

*** Building Squirrel standalone REPL interpreter 

Download and build: 


#+BEGIN_SRC sh 
  $ mkdir ~/build && cd build 
  $ git clone https://github.com/albertodemichelis/squirrel
  $ cmake -H. -B_build -DCMAKE_BUILD_TYPE=Debug 
  $ cmake --build _build --target
#+END_SRC

Play with squirrel interactive shell (REPL):

#+BEGIN_SRC sh 
  $ _build/bin/sq
  Squirrel 3.1 stable Copyright (C) 2003-2017 Alberto Demichelis (64 bits)

  sq> print(" === Hello world Squirrel === ")
   === Hello world Squirrel === 

  sq> function add_to_10(x){ return x + 10; }

  sq>print(add_to_10(25))
  35

  sq> x <- cos(3.1415 / 2) + 10 

  sq>print(" x = " + x.tostring())
   x = 10

  sq> for(local i = 0; i < 5; i++) print(" \n [TRACE] i = " + i.tostring());

   [TRACE] i = 0 
   [TRACE] i = 1 
   [TRACE] i = 2 
   [TRACE] i = 3 
   [TRACE] i = 4
#+END_SRC

*** Example - embedding Squirrel with Squall Library 

This example demonstrates how to embed the Squirrel programming
language in a C++ application using the Squall header-only library. 

   + Squal Repository: https://github.com/jonigata/squall

   + Note: This project is self-contained, no library needs to be
     installed on the system as Squall automatically fetches Squirrel
     sources using Cmake FetchContent. 

 *Sample Project* 

File: CMakeLists.txt 

#+BEGIN_SRC cmake 
   cmake_minimum_required (VERSION 3.11)
   project(squirrel_squall_test)

   set(CMAKE_CXX_STANDARD 17)
   set(CMAKE_CXX_STANDARD_REQUIRED on)
   set(BUILD_EXAMPLES off)

   # -----------------------------------------------#
   include(FetchContent)

   FetchContent_Declare(
     squall 
     URL      https://github.com/jonigata/squall/archive/master.zip
     )

   FetchContent_MakeAvailable(squall)

   #-------- TARGET DEFINITIONS --------------------#
   message([TRACE] " squall_SOURCE_DIR = ${squall_SOURCE_DIR}/squall  ")

               add_executable ( squirrel-test squirrel_test.cpp)
        target_link_libraries ( squirrel-test squirrel_static sqstdlib_static)
   target_include_directories ( squirrel-test PUBLIC
                                  ${squirrel_SOURCE_DIR}/include
                                  ${squall_SOURCE_DIR}
                                  )
#+END_SRC

File: squirrel_test.cpp 

#+BEGIN_SRC cpp 
   #include <iostream>
   #include <string>
   #include <algorithm>
   #include <vector> 

   #include <squall/squall_vmstd.hpp>
   #include <squall/squall_klass.hpp>

   void some_cpp_fun(int n )
   {
       for(int i = 0; i < n; i++)
           std::printf("\n   [some_cpp_function] => i = %d ", i);
   }

   class ChartXY
   {
       int m_width; 
       int m_height;
   public:
       ChartXY(): m_width(20), m_height(50) 
       {
           std::cout << " [ChartXY] Ctor() - I was created!. OK. " << std::endl;
       }

       void set_width(int x){ m_width = x; }
       void set_height(int x){ m_height = x; }

       void draw() const 
       { 
           std::printf(" [ChartXY] draw() => Draw chart with: width = %d ; height = %d"
                       , m_width, m_height);
       }
   };

   int main()
   {
       // Create a virtual-machine object for Squirrel language 
       // Note: throws squall::squirrel_error
       squall::VMStd vm; 

       // ------------------------------------------------------------------------//
       // [EXPERIMENT 1] Evaluate scripts provided as strings                     //
       //-------------------------------------------------------------------------//
       std::puts(" =>> [EXPERIMENT] 1 - Evaluating code as string. ");  
       std::puts(" ---------------------------------------------\n");

       try {

           vm.dostring(R"( 
               // --- Squirrel Comment ----- // 
               print(" <SQUIRREL>  =>> Hello world squirrel!");

               function myfunc(x) {  
                   local a = x + 5;
                   local b = 7 * a + x;
                   return b - a + 10;  
               }

               function myfunc2() {
                   print(" \n  <SQUIRREL> I was called by the C++ code ");
               }

               print("\n <SQUIRREL> =>> myfunc(4) = " + myfunc(4).tostring() );

               print("\n\n <SQUIRREL> --- For Loop test ---- ");
               for(local i = 0; i < 5; i++) { 
                    print("\n   i = " + i.tostring() );  
               }
           )");

       } catch( squall::squirrel_error const& ex )
       {
           std::cerr << "\n [SQUIRREL ERROR] Error =>  " << ex.what() << std::endl;        
       }

       // ------------------------------------------------------------------------//
       // [EXPERIMENT 2] Evaluate scripts provided as strings                     //
       //-------------------------------------------------------------------------//
       std::puts("\n =>> [EXPERIMENT] 2 - Getting variables defined in the code.");  
       std::puts(" -----------------------------------------------------------\n");

       {
           vm.dostring(R"( 
               // ---- Global varibles for configuration ------ // 
               ::myvar_width <- 100;
               ::myvar_float <- 122.56161;
               ::myvar_string <- "/path/to/interpreter.exe"; 
           )");

           squall::TableBase table = vm.root_table();
           auto myvar_float = table.get<float>("myvar_float");       
           auto myvar_width = table.get<int>("myvar_width");
           auto myvar_string = table.get<std::string>("myvar_string");
           std::cout << "  =>>  myvar_width = " << myvar_width << std::endl;
           std::cout << "  =>>  myvar_float = " << myvar_float << std::endl;
           std::cout << "  =>> myvar_string = " << myvar_string << std::endl;
       } 

       // ------------------------------------------------------------------------//
       // [EXPERIMENT 3] Call functions defined in the script (Virtual Machine )  //
       //-------------------------------------------------------------------------//    
       std::puts("\n\n =>> [EXPERIMENT] 3 - Calling functions defined in the script (VM)");
       std::puts(" ------------------------------------------------------------------\n");    
       // Throws: 'squall::squirrel_error' 
       int result = vm.call<int>("myfunc", 10);
       std::cout << "   =>>> myfunc(4) = " << result << std::endl;

       vm.call<void>("myfunc2");

       // ------------------------------------------------------------------------//
       // [EXPERIMENT 4] Call C++ functions from the script                       //
       //-------------------------------------------------------------------------//    
       std::puts("\n\n =>> [EXPERIMENT] 4 - Calling functions defined in the script (VM)");
       std::puts(" ------------------------------------------------------------------\n");

       // Register C++ function pointer 
       vm.defun("some_cpp_fun", &some_cpp_fun);

       vm.dostring(R"(
           print(" \n [SQUIRREL] => Call C++ function some_cpp_fun() ");
           some_cpp_fun(5);
        )");


       // Register C++ lambda object 
       vm.defun("call_me", [=](std::string const& param) {
           std::cout << "\n [TRACE] call_me() Parameter = " << param << "\n";
           return  " name = " + param;
       });

       vm.dostring(R"(
           local x = call_me("<SQUIRREL-INTERPRETER>");
           print(" [SQUIRREL] \n x <- " + x);
        )");

       // ------------------------------------------------------------------------//
       // [EXPERIMENT 5] Call C++ classes from Squirrel-side                     //
       //-------------------------------------------------------------------------//    
       std::puts("\n\n =>> [EXPERIMENT] 5 - Calling C++ classes from Squirrel        ");
       std::puts(" ------------------------------------------------------------------\n");

       // Create metaobject 'k' that describes ChartXY class 
       squall::Klass<ChartXY> k(vm, "ChartXY");
       k.func("set_width",  &ChartXY::set_width);
       k.func("set_height", &ChartXY::set_height);
       k.func("draw",       &ChartXY::draw);

       vm.dostring(R"( 
           function manipulate_chart(ch){           
               ch.set_width(25);
               ch.set_height(10);
               ch.draw();
           }

           function draw_with(ch, w, h)
           {
               print(" \n [SQUIRREL LOG] Function draw_with called. OK. \n");
               ch.set_width(w);
               ch.set_height(h);
               ch.draw();
           }
        )");

       ChartXY mychart;
       vm.call<void>("manipulate_chart", &mychart);
       vm.call<void>("draw_with", &mychart, 100, 200);

       std::cout << "\n\n";

       squall::TableBase table = vm.root_table();

       // Pass object to Squirrel side 
       table.set("mychart", mychart);

       vm.dostring(R"(
           mychart.set_width(250);
           mychart.set_width(600);
           mychart.draw();
       )");


   #if 0  
       // Segmentation Falt Coredump if the C++ object 
       // is created on the Squirrel-side.
       vm.dostring(R"(
           local c = ChartXY();
           c.set_width(150);
           c.set_height(175);
           c.draw();
       )");
   #endif 

       return 0;
   }
#+END_SRC

Build: 

#+BEGIN_SRC sh 
   $ cmake -H. -B_build -DCMAKE_BUILD_TYPE=Debug 
   $ cmake --build _build --target 
#+END_SRC

Check executable dependencies: 

#+BEGIN_SRC sh 
 $ ldd _build/squirrel-test 
	linux-vdso.so.1 (0x00007ffe34dd6000)
	libstdc++.so.6 => /lib64/libstdc++.so.6 (0x00007fd3ebd2a000)
	libm.so.6 => /lib64/libm.so.6 (0x00007fd3ebbe4000)
	libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x00007fd3ebbc9000)
	libc.so.6 => /lib64/libc.so.6 (0x00007fd3eb9ff000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fd3ebf3e000)
#+END_SRC

Run application: 

#+BEGIN_SRC sh 
   $ _build/squirrel-test 

   =>> [EXPERIMENT] 1 - Evaluating code as string. 
   ---------------------------------------------

   <SQUIRREL>  =>> Hello world squirrel!
   <SQUIRREL> =>> myfunc(4) = 68

   <SQUIRREL> --- For Loop test ---- 
     i = 0
     i = 1
     i = 2
     i = 3
     i = 4
   =>> [EXPERIMENT] 2 - Getting variables defined in the code.
   -----------------------------------------------------------

    =>>  myvar_width = 100
    =>>  myvar_float = 122.562
    =>> myvar_string = /path/to/interpreter.exe


   =>> [EXPERIMENT] 3 - Calling functions defined in the script (VM)
   ------------------------------------------------------------------

     =>>> myfunc(4) = 110

    <SQUIRREL> I was called by the C++ code 

   =>> [EXPERIMENT] 4 - Calling functions defined in the script (VM)
   ------------------------------------------------------------------


   [SQUIRREL] => Call C++ function some_cpp_fun() 
     [some_cpp_function] => i = 0 
     [some_cpp_function] => i = 1 
     [some_cpp_function] => i = 2 
     [some_cpp_function] => i = 3 
     [some_cpp_function] => i = 4 
   [TRACE] call_me() Parameter = <SQUIRREL-INTERPRETER>
   [SQUIRREL] 
   x <-  name = <SQUIRREL-INTERPRETER>

   =>> [EXPERIMENT] 5 - Calling C++ classes from Squirrel        
   ------------------------------------------------------------------

   [ChartXY] Ctor() - I was created!. OK. 
   [ChartXY] draw() => Draw chart with: width = 25 ; height = 10 
   [SQUIRREL LOG] Function draw_with called. OK. 
   [ChartXY] draw() => Draw chart with: width = 100 ; height = 200

   [ChartXY] draw() => Draw chart with: width = 600 ; height = 200


#+END_SRC
** Duktape - Embeddable Javascript Engine 
*** Overview 

  + Duktape is a small footprint embeddable Javascript (ECMAScript)
    engine, written in C, which can be used for providing scripting
    capabilities for C or C++ applications.

  + License: MIT

  + Possible Use Cases:
    + Configuration
    + Data description language
    + User plugins
    + User extensions
    + Scripting for games 

  + Features:
    + Embeddable, portable, compact: can run on platforms with 160kB
      flash and 64kB RAM 
    + Built-in debugger
    + Built-in regular expression engine
    + Minimal, retargetable platform dependencies
    + Combined reference counting and mark-and-sweep garbage
      collection with finalization 
    + Bytecode dump/load for caching compiled functions
    + Distributable includes an optional logging framework,
      CommonJS-based module loading implementations, etc 

 *Official Website* 

  + https://duktape.org/

  + https://duktape.org/download.html
   
 *Official Repository* 

   + https://github.com/svaarala/duktape 

  *C++ Binding Libraries*  

   + https://github.com/Aloshi/dukglue/    

   + https://github.com/stfwi/duktape-cc
*** Example project with DukGlue C++ binding library 

This following project CMakeLists.txt automatically downloads _dukglue_
binding library and _duktape_ engine sources and builds a C++ demonstration
code embedding duktape JavaScript engine. 

  + DukGlue Binding Library: https://github.com/Aloshi/dukglue
    + Advantage:
      * Easy to use and lots of examples. 
    + Drawbacks:
      * Lack of namespaces which enhances API discoverability
      * Lack of C++ wrappers to some Duktape C-types
      * Lack of a CMakeLists.txt at the top directory. 

File: CMakeLists.txt 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.0)
  project(duktap-embed)

  include(FetchContent)

  # Download library archive (zip, *.tar.gz, ...) from URL
  macro(Download_Library_Url NAME URL)
    FetchContent_Declare(${NAME} URL  ${URL})
    FetchContent_GetProperties(${NAME})
    if(NOT ${NAME}_POPULATED)
      FetchContent_Populate(${NAME})
     # add_subdirectory(${${NAME}_SOURCE_DIR} ${${NAME}_BINARY_DIR})
    endif()
  endmacro()


  # ====>> Duktape JavaScript Engine Configuration <<===========#

  Download_Library_Url(duktape
    "https://duktape.org/duktape-2.5.0.tar.xz"
    )

  # FetchContent_MakeAvailable(duktape)

  message( [TRACE] " =>> duktape_SOURCE_DIR = ${duktape_SOURCE_DIR} ")


  file(GLOB_RECURSE duktape_sources "${duktape_SOURCE_DIR}/src/*.c")
  file(GLOB_RECURSE duktape_headers "${duktape_SOURCE_DIR}/src/*.h")

  message( [TRACE] " duktape_sources = ${duktape_sources} ")

                add_library (duktape ${duktape_sources} ${duktape_headers} )
  target_include_directories(duktape PUBLIC ${duktape_SOURCE_DIR}/src  )

  # ----------- DukGlue Library ----------------------------#

  FetchContent_Declare(
    dukglue 
    URL       https://github.com/Aloshi/dukglue/archive/master.zip
    )

  FetchContent_MakeAvailable(dukglue)

  #----- Main Target Definition ----------------------------#
  add_executable(duktape-embed duktape-embed.cpp)
  target_link_libraries(duktape-embed duktape dukglue)

#+END_SRC

File: duktape-embed.cpp 

#+BEGIN_SRC cpp 
   #include <iostream>
   #include <string>
   #include <vector>
   #include <cassert> 

   // Repository: https://github.com/Aloshi/dukglue
   #include <dukglue/dukglue.h>

   void print_number(int x)
   {
     std::cout << " [TRACE] number passed is = " << x << std::endl;
   }

   void log_text(std::string const& text)
   {
       std::cout <<  " =>> [C++-LOG] - " << text << std::endl;
   }

   int eval_code(duk_context* ctx, std::string const& code)
   {
       return duk_peval_string(ctx, code.c_str());
   }

   void plot_points(std::vector<float> const& points)
   {
     std::cout << "  =>> [TRACE] Plot points  =>> ";
     for(auto const& x: points) { std::cout << " x = " << x; }
     std::cout << " \n";
   }

   class Counter {
   private: 
       std::string m_name;
       int         m_counter;

   public: 

       // Ctor [1] => Default ctor 
       Counter(): Counter("untitled", 0) { }

       // Ctor [2]
       Counter(std::string name, int counter)
         : m_name{std::move(name)}, m_counter{counter}
       { 
           std::cout << " [TRACE] Counter created with =>  { " 
                     <<   " name = " << m_name 
                     << " ; counter = " << m_counter 
                     << " } \n";
       }

       int getCounter() const { return m_counter; }
       void setCounter(int n) {       
         m_counter = n; 
         std::cout << " [TRACE] I was set to value " << n << std::endl;
       }

       void increment() {       
         m_counter++; 
         std::cout << " [TRACE] increment event =>> counter = {  " 
                   << m_name << " ; " << m_counter 
                   << " } " << std::endl;
       }    

   };


   int main()
   {
         // Create Duktape Virtual machine 
         duk_context* ctx = duk_create_heap_default();

         /* ========================== EXPERIMENT 1 =============*/
         std::puts("\n === [EXPERIMENT 1] ==>> Register and call C++ functions <<===== ");
         {
             // Register pointer to functions function (function pointer) in 
             // the JS engine (aka virtual machine)
             dukglue_register_function(ctx, &print_number, "print_number"); 
             dukglue_register_function(ctx, log_text, "log_text");
             dukglue_register_function(ctx, plot_points, "plot_points");

             const char* code1 = R"(
                 print_number(10);
                 log_text(" Hello world from Javascript" ); 
                 log_text(" Toke is equal to " + 100 ); 
                 log_text( " " + 1000 );      

                 plot_points( [ 20.5, 100.23, -125.254, 8.251, 100.0 ]);
             )";

             // Evaluate code, returns false on error 
             auto n = eval_code(ctx, code1);

             if(n) { std::cerr << " [ERROR] A duktape evaluation error has happened. "  << std::endl; }

         }

         /* ========================== EXPERIMENT 2 ====================*/
         std::puts("\n === [EXPERIMENT 2] ==>> Register and call C++ classes <<===== \n");
         {
             // Register class counter 
             dukglue_register_constructor<Counter>(ctx, "Counter");      
             dukglue_register_constructor<Counter, std::string, int>(ctx,  "Counter");     
             dukglue_register_method(ctx, &Counter::getCounter , "getCounter");
             dukglue_register_method(ctx, &Counter::setCounter , "setCounter");
             dukglue_register_method(ctx, &Counter::increment , "increment");

             dukglue_register_property(ctx                   // Pointer to engine (VM)
                                     , &Counter::getCounter  // Getter 
                                     , &Counter::setCounter  // Setter 
                                     , "number"              // Property name 
                                     );

             int ret = eval_code(ctx, R"( 
                 var counter = new Counter("mycounter", 10); 

                 for(i = 0 ; i < 5; i++) { counter.increment(); }

                 var n = counter.getCounter(); 
                 log_text(" [BEFORE] Counter value = " + n );

                 counter.setCounter(100);
                 log_text(" [AFTER 1 ] Counter value = " + counter.getCounter() );

                 counter.number = 400;
                 log_text(" [AFTER 2] Counter value = " + counter.number );
             )");
             assert( ret == 0 );

         }

         /* ======= Calling Javascript Engine from C++ ====================*/
         // Note: It is useful for reading data or user configuration 
         std::puts("\n === [EXPERIMENT 3] ==>> Calling engine objects from C++ <<===== \n");
         {
             const char* code = R"(
               // Global variables for configuration 
               points = 200; 
               asset_path = "C:\\\\Users\\dummy\\data\\graphics";

               function my_js_function(n){
                   log_text( " <my_js_function> =>> n = " + n );
                   var k = 20 * n + 100;
                   return k; 
               }

             )";
             eval_code(ctx, code);

             // Throws error: DukErrorException
             auto points = dukglue_peval<int>(ctx, "points");
             std::cout << "  [*] =>> points = " << points << std::endl;

             // Throws error: DukErrorException
             auto asset_path = dukglue_peval<std::string>(ctx, "asset_path");
             std::cout << "  [*] =>> asset_path = " << asset_path << std::endl;

             auto jsexpr = dukglue_peval<double>(ctx, "3.51 * 10.52 - 8.251 / 100");
             std::cout << "  [*] jsexpr = " << jsexpr << std::endl;

             // Call Javascript function from C++ 
             auto func = dukglue_peval<DukValue>(ctx, "my_js_function");
             int res = dukglue_pcall<int>(ctx, func, 20);
             std::cout << "  [*] res = " << res << std::endl;

         }

       // Release Javascript engine object (aka virtual machine)
       ::duk_destroy_heap(ctx);

       return 0;
   }

#+END_SRC

Build: 

#+BEGIN_SRC sh 
  $ cmake -H. -B_build -DCMAKE_BUILD_TYPE=Debug
  $ cmake --build _build --target 
#+END_SRC

Program output: 

#+BEGIN_SRC sh 
   $ ./build/duktape-embed 

   === [EXPERIMENT 1] ==>> Register and call C++ functions <<===== 
   [TRACE] number passed is = 10
   =>> [C++-LOG] -  Hello world from Javascript
   =>> [C++-LOG] -  Toke is equal to 100
   =>> [C++-LOG] -  1000
    =>> [TRACE] Plot points  =>>  x = 20.5 x = 100.23 x = -125.254 x = 8.251 x = 100 

   === [EXPERIMENT 2] ==>> Register and call C++ classes <<===== 

   [TRACE] Counter created with =>  {  name = mycounter ; counter = 10 } 
   [TRACE] increment event =>> counter = {  mycounter ; 11 } 
   [TRACE] increment event =>> counter = {  mycounter ; 12 } 
   [TRACE] increment event =>> counter = {  mycounter ; 13 } 
   [TRACE] increment event =>> counter = {  mycounter ; 14 } 
   [TRACE] increment event =>> counter = {  mycounter ; 15 } 
   =>> [C++-LOG] -  [BEFORE] Counter value = 15
   [TRACE] I was set to value 100
   =>> [C++-LOG] -  [AFTER 1 ] Counter value = 100
   [TRACE] I was set to value 400
   =>> [C++-LOG] -  [AFTER 2] Counter value = 400

   === [EXPERIMENT 3] ==>> Calling engine objects from C++ <<===== 

    [*] =>> points = 200
    [*] =>> asset_path = C:\\Users\dummy\data\graphics
    [*] jsexpr = 36.8427
   =>> [C++-LOG] -  <my_js_function> =>> n = 20
    [*] res = 500


#+END_SRC
*** Example project with Duktape-CC binding library 

  + Duktape-CC binding library: https://github.com/stfwi/duktape-cc/
    + Benefits 
      + Namespace 
      + RAII for duktape C-API
      + Javascript common known APIs such as console.log()
    + Disadvantage:
      + No possible to bind lambda function. 
      + No possible to bind C++ classes or objects
      + No CMakeLists.txt at top directory, which makes the library
        usage easier, but the following cmake scripts solves this
        problem.


File: CMakeLists.txt 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.0)
  project(duktape-cc-trial)

  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_VERBOSE_MAKEFILE ON)

  include(duktape.cmake)

  #----- Main Target Definition ----------------------------#
         add_executable( duktape-script duktape-script.cpp)
  target_link_libraries( duktape-script duktape-cc )
#+END_SRC

File: duktape.cmake 

#+BEGIN_SRC cmake 
   include(FetchContent)

   # Note: the 'add_subriectory' line was commented becuyase 
   #       library that will be downloaded does not have 
   #       a CMakeListst.txt file at the root directory. 
   macro(Download_Library_Git  NAME TAG REPOSITORY_URL)
       FetchContent_Declare(
           ${NAME}
           GIT_REPOSITORY  ${REPOSITORY_URL}
           GIT_TAG         ${TAG}
       )
       FetchContent_GetProperties(${NAME})
       if(NOT cpputest_POPULATED)
           FetchContent_Populate(${NAME})
           message("${NAME}_SOURCE_DIR} = ${${NAME}_SOURCE_DIR}")        

           # => Disable following line: the library does not have a CMakeLists.txt
           #    at the root directory.
           # add_subdirectory(${${NAME}_SOURCE_DIR} ${${NAME}_BINARY_DIR})
       endif()
   endmacro()


   # ====>> Duktape JavaScript Engine Configuration <<===========#

   Download_Library_Git( duktape-cc 
                         51fed200b0c3353a60fa560aa8a13a480f0ec0c7
                         https://github.com/stfwi/duktape-cc/
                       )

   file(GLOB_RECURSE duktape_sources "${duktape-cc_SOURCE_DIR}/duktape/*.c")
   file(GLOB_RECURSE duktape_headers1 "${duktape-cc_SOURCE_DIR}/duktape/*.hh")
   file(GLOB_RECURSE duktape_headers2 "${duktape-cc_SOURCE_DIR}/duktape/*.h")

                  add_library( duktape-cc ${duktape_sources} ${duktape_headers1} ${duktape_headers2} )
   target_include_directories( duktape-cc PUBLIC ${duktape-cc_SOURCE_DIR} )

#+END_SRC

File: duktape-script.cpp 

#+BEGIN_SRC cpp 
   #include <iostream> 
   #include <string> 
   #include <vector> 
   #include <fstream>

   #include <duktape/duktape.hh>
   #include <duktape/mod/mod.stdio.hh>

   int main()
   {
       std::puts(" [TRACE] Program started Ok. ");

       // Create Duktape Engine object (Virtual Machine)
       auto ctx = duktape::engine{};

       // Load all functions from stdio module 
       // ==> Note: It is necessary for console.log() work 
       duktape::mod::stdio::define_in(ctx);   


       std::puts("\n [EXPERIMENT 1] ======= Evaluate string as code ========");

       ctx.eval<void>(R"( 
           console.log(" [INFO] Hello world Javascript Engine ");

           var i = 0;
           while(i < 5) {
               console.log(" [TRACE] <ducktape>  i = " + i);
               i++;
           }
       )");

       std::puts("\n [EXPERIMENT 2] == Read/write values to the engine the engine =");

       // Write or pass values to the engine. 
       ctx.define("app.version", "0.251");
       ctx.define("user.points", 1000);
       ctx.define("array1", std::vector<double>{ 4.51, 9.25, -25.154, 205.2 });
       ctx.define("array2", std::vector<std::string>{ "C++", "ADA-Spark", "Rust", "Dlang", "OCaml" });

       std::string script_file = "/tmp/myscript.js";

       const char* script_code = R"(
           console.log("  => app.version = " + app.version );
           console.log("  => user.points = " + user.points );
           console.log("  => array1 = " + array1);
           console.log("  => array2 = " + array2);

           myconfig_path = "/Users/data/osx/config";
           user_credits = 1020; 
           vector = [100.25, 90.251, -120.5150];
       )";

       // Write script code to file     
       auto fs = std::ofstream(script_file);
       // Flush forces writing to the IO
       fs << script_code << std::flush;          
       // Execute script from file 
       ctx.include(script_file);

       std::cout << " ---- Read configuration from file " << std::endl; 

       // Throws exception: duktape::detail::basic_script_error<void>
       auto myconfig_path = ctx.eval<std::string>("myconfig_path");
       auto credits       = ctx.eval<int>("user_credits");
       auto vec           = ctx.eval<std::vector<double>>("vector");
       std::cout << "\n\n[*] my_config_path = " << myconfig_path << "\n";
       std::cout << "[*]   user_credits = " << credits << "\n";
       std::cout << "[*] vec[0] = " << vec[0] << " ; vec[1] = " << vec[1] << "\n";    

       return 0;
   }
#+END_SRC

Build: 

#+BEGIN_SRC sh 
  $ cmake -H. -B_build -DCMAKE_BUILD_TYPE=Debug
  $ cmake --build _build --target 
#+END_SRC

Program output: 

#+BEGIN_SRC sh 
   $ _build/duktape-script 
   [TRACE] Program started Ok. 

   [EXPERIMENT 1] ======= Evaluate string as code ========

   [EXPERIMENT 2] == Read/write values to the engine the engine =
   [INFO] Hello world Javascript Engine 
   [TRACE] <ducktape>  i = 0
   [TRACE] <ducktape>  i = 1
   [TRACE] <ducktape>  i = 2
   [TRACE] <ducktape>  i = 3
   [TRACE] <ducktape>  i = 4
    => app.version = 0.251
    => user.points = 1000
    => array1 = 4.51,9.25,-25.154,205.2
    => array2 = C++,ADA-Spark,Rust,Dlang,OCaml
   ---- Read configuration from file 


  [*] my_config_path = /Users/data/osx/config
  [*]   user_credits = 1020
  [*] vec[0] = 100.25 ; vec[1] = 90.251

#+END_SRC

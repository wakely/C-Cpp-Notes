#+INCLUDE: theme/style.org 
#+TITLE: CPP / C++ Notes - C++ Tooling
#+DESCRIPTION: c c++ cpp tooling utilities instrumentation 
#+STARTUP: content  

* Tooling 
** Online Tools 
*** Compilers                                        :compiler:

    + https://coliru.stacked-crooked.com/
      + The only online compiler which supports C++17 and the experimental
        C++20. 

    + http://rextester.com/
      + The main selling point of this online tool is that it allows to
        save code snippets and run them again. 
      + Online C++ compiler, provides GCC, CLANG and Visual Studio
        Compiler, also known as MSVC (VC++ - Visual C++).
      + Supports Boost libraries.

    + https://repl.it/languages/cpp11
      + Oline compiler (GCC / C++11 only) with REPL support.

    + https://wandbox.org/ (Best)
      + Supports C++11, C++14, C++17 and C++20a (draft).
      + Supports Boost libraries.
      + Supported Languages other C++:
        + Non-managed languages: C, Rust, D, Go C#, CMake,  Nim, Haskell, Nim
        + Managed languages: C#, Java,  R, Scala, Swift, PHP, Ruby, SQL
          and so on.
*** Compiler Explorers                                      :compiler:

    + https://godbolt.org/ [BEST]
      * Compiler explorer - allows to explore the assembly generated by a
        wide variety of compilers, including, GNU GCC, Clang, MSVC and
        so on.
    + https://www.onlinegdb.com [BEST]
      * Online GNU Debugger

    + https://cppinsights.io
      + "C++ Insights is a clang-based tool which does a source to
        source transformation. Its goal is to make things visible which
        normally, and intentionally, happen behind the scenes. It's
        about the magic the compiler does for us to make things
        work. Or looking through the classes of a compiler. You can
        see, for example the transformation of a lamda, range-based
        for-loop or auto. Of course, you can transform any other C++
        snippet. "

    + https://macro.virhex.com/
      + Macro expander tool 

    + https://demangler.com/
      * Symbol demangler for MSVC, GCC and Clang.

    + http://quick-bench.com
      + Tool for micro benchamrks  

    + http://metashell.org/index.html
      + Tool for visualizing template expansion 
*** Web Assembly 

    + https://mbebenita.github.io/WasmExplorer/
      + "Here you can translate C/C++ to WebAssembly, and then see the
        machine code generated by the browser. For bugs, comments and
        suggestions see: https://github.com/mbebenita/WasmExplorer
        built with Clang/LLVM, AngularJS, Ace Editor, Emscripten,
        SpiderMonkey, Binaryen and Capstone.js."

    + https://webassembly.studio/

*** Assembly  

  + [[https://www.tutorialspoint.com/compile_assembly_online.php][Assembly x86 - NASM Compiler / TutorialsPoints]]

  + http://shell-storm.org/online/Online-Assembler-and-Disassembler/

  + https://www.jdoodle.com/compile-assembler-nasm-online/

  + https://defuse.ca/online-x86-assembler.htm
    + "This tool takes x86 or x64 assembly instructions and converts
      them to their binary representation (machine code). It can also
      go the other way, taking a hexadecimal string of machine code
      and transforming it into a human-readable representation of the
      instructions. It uses GCC and objdump behind the scenes. You can
      use this tool to learn how x86 instructions are encoded or to
      help with shellcode development." 
*** Emulators 

  + *ARMv7 DEC1-Soc CPU Emulator*
    + <https://cpulator.01xz.net/?sys=arm-de1soc>
    + https://cpulator.01xz.net/doc/
    + "CPUlator is a simulator and debugger of a computer system (CPU,
      memory, and I/O devices) that runs inside a web
      browser. Simulation allows running and debugging programs
      without needing to use a hardware board. When you load a program
      onto the simulator, the program will behave (almost) identically
      to the same program running on real hardware. The simulated
      systems are based on the computer systems from the Altera
      University Program (Nios II and ARMv7) or SPIM (MIPS). A
      simulator has several advantages over hardware. It is more
      convenient and easily accessible than a hardware board. Also,
      compared to hardware, a simulator has greater visibility into
      the system state and can warn about suspicious behaviours, such
      as self-modifying code or violating calling conventions, making
      debugging easier."

  + *Unicorn.js - The Unicorn emulator framework, now available for JavaScript.*
    + <https://alexaltea.github.io/unicorn.js/>
    + https://news.ycombinator.com/item?id=13570281
    + "Unicorn.js is a port of the Unicorn emulator framework for
      JavaScript, done with Emscripten. It's released as a 19 MB
      JavaScript file supporting the architectures: ARM, ARM64, M68K,
      MIPS, SPARC, and x86. Alternatively, per-platform Unicorn.js
      releases are also available here. Follow the Readme to build
      Unicorn.js manually. Unicorn is a lightweight multi-architecture
      CPU emulator framework originally developed by Nguyen Anh Quynh
      et al. and released under GPLv2."

*** Misc Tools 

  *Regex Testers* 

  + https://myregextester.com/index.php

  + [[https://regexr.com/][RegExr: Learn, Build, & Test RegEx]]

  + https://regex101.com/

  *UML Ascii/Text Drawing Tools*  

    * [[http://asciiflow.com/][ASCIIFlow Infinity]] (Pick-and place)
      * Allows to draw Ascii UML box diagrams by dragging and dropping
        like in MS-Paint.

    * http://stable.ascii-flow.appspot.com/ (Pick-and place)

    * https://textik.com/ (Pick-and place)

    * https://www.planttext.com/ (Latex-like)

    * https://textart.io/sequence  (Latex-like)
      * UML Sequence Diagram drawing tool. The user writes the commands
        and the tool draws the diagram. It adopts an approach similar
        to Tex/Latex.

  * *MISC*
    + [[https://www.google.ca/search?q=float%20point%20online][float point online - Google Search]]
    + [[https://www.h-schmidt.net/FloatConverter/IEEE754.html][IEEE-754 Floating Point Converter]]
    + [[http://weitz.de/ieee/][IEEE 754 Calculator]]
*** Database SQL RDBMS 

  *SQL Simulator / Playground* 

   + https://www.db-fiddle.com/ => Database SQL Snippets

   + [[https://rextester.com/l/sql_server_online_compiler][compile sql server online]] (Microsft SQL Server Simulator)

   + [[https://www.w3schools.com/sql/trysql.asp?filename=trysql_op_in][SQL Tryit Editor v1.6]]

   + [[https://www.tutorialspoint.com/execute_sql_online.php][Online Sqlite Compiler - Online Sqlite Editor]]

   + [[https://livesql.oracle.com/apex/f?p=590:1000][Oracle Live SQL]]

  *Tools for creating database schema* 

    * https://dbdiagram.io/d
      + Tool for creating Database schema 

 *Tools for translating SQL Dialects* 

    * [[https://www.jooq.org/translate/][Translate your SQL from one dialect to another]]

    * http://www.sqlines.com/online
      + Convert between SQL dialects PostgresSQL, MySQL, OracleDB,
        MariaDB (MySQL fork), Microsft SQL Server ...

    * [[http://www.querymongo.com/][Query Mongo: MySQL to MongoDB Query Translator]]
      + Conversts SQL queries to MongoDB (NonSQL) queries.
*** Latex - Equations and Math Formulas 

   + *Latex Equatuion Editor - Codecogs*
     + https://www.codecogs.com/latex/eqneditor.php

   + *QuickLaTeX*
     + https://www.quicklatex.com/

   + *Sciweavers*
     + http://www.sciweavers.org/free-online-latex-equation-editor

   + *LaTeX Tables Generator*
     + https://www.tablesgenerator.com/

   + *Online Bibtex Editor*
     + https://truben.no/latex/bibtex/

   + *Latex Templates for Algorithms and Pseudo-code*
     + https://www.overleaf.com/learn/latex/algorithms

** Compilers and toolchains 
*** MINGW/GCC and Clang

 *Clang / LLVM* 
  
  + https://clang.llvm.org/

 *Windows / GCC-MingW*  

  + [[http://www.mingw.org/][MinGW Compiler]] [Official Web Site]

  + [[http://mingw-w64.org/doku.php/download][mingw-w64 - GCC for Windows 64 & 32 bits]] [Download] 

  + [[https://nuwen.net/mingw.html][Mingw - newen.net Distribution]] (GCC Ported for Windows)
    + "My MinGW distribution ("distro") is x64-native and currently
      contains GCC 9.2.0 and Boost 1.71.0. - The components of this
      distro fall into four categories: Essentials: The components of
      MinGW itself. They are required in order to run GCC;  Libraries:
      Useful C and C++ libraries; Utilities: Programs used by
      programmers;  Utilities (Binary): More programs used by
      programmers. Unlike everything else, I obtained these
      executables from their official websites instead of building
      them myself."
*** Web - WebAssembly / WASM / asm.js
 
   + *Emscripten* - Emscripten: An LLVM-to-Web Compiler
     + https://github.com/emscripten-core/emscripten
     + "Emscripten compiles C and C++ to WebAssembly using LLVM and
       Binaryen. Emscripten output can run on the Web, in Node.js, and
       in wasm runtimes. Emscripten provides Web support for popular
       portable APIs such as OpenGL and SDL2, allowing complex
       graphical native applications to be ported, such as the Unity
       game engine and Google Earth. It can probably port your
       codebase, too! While Emscripten mostly focuses on compiling C
       and C++ using Clang, it can be integrated with other LLVM-using
       compilers (for example, Rust has Emscripten integration, with
       the wasm32-unknown-emscripten and asmjs-unknown-emscripten
       targets)." 

   + *Emcsripten SDK*
     + https://github.com/emscripten-core/emsdk
     + https://developer.mozilla.org/en-US/docs/WebAssembly/C_to_wasm
     + https://webassembly.org/getting-started/developers-guide/
     + "Emscripten toolchain is distributed as a standalone Emscripten
       SDK. The SDK provides all the required tools, such as Clang,
       Python and Node.js along with an update mechanism that enables
       migrating to newer Emscripten versions as they are
       released. You can also set up Emscripten from source, without
       the pre-built SDK, see "Installing from Source" below."

   + [[https://github.com/leaningtech/cheerp-meta][Cheerp]] - Cheerp - a C/C++ compiler for Web applications
     + https://leaningtech.com/cheerp/
     + "Cheerp is a C/C++ compiler for the Web, based and integrated
       into the LLVM/clang infrastructure, and featuring numerous
       custom optimisation steps to maximise performance and minimise
       size of the compiled JavaScript/WebAssembly output. As such,
       Cheerp is the best performing, most optimised C++ to
       WebAssembly compiler available on the market Cheerp is used
       mainly to port existing C/C++ libraries and applications to
       HTML5, but can also be used to write high-performance Web
       applications and components from scratch. C/C++ gets optimised
       and compiled into JavaScript/WebAssembly, and can easily be
       deployed as part of a web page."
*** Mobile Devices / Android 

 *Android* (Cross compiler for Linux running on ARM or MIPS)

  + https://developer.android.com/ndk
    + Old NDK - used GCC compilers, new NDK uses Clang/LLVM compiler.

Side Note: Android is "Linux" with BSD-license LibC and user-space
utilities provided by _toybox_.
*** Embedded Systems / Microcontrollers / SBC 

  + [[http://sdcc.sourceforge.net/][SDCC Compiler]]
    + "SDCC is a retargettable, optimizing Standard C (ANSI C89, ISO
      C99, ISO C11) compiler suite that targets the Intel MCS51 based
      microprocessors (8031, 8032, 8051, 8052, etc.), Maxim (formerly
      Dallas) DS80C390 variants, Freescale (formerly Motorola) HC08
      based (hc08, s08), Zilog Z80 based MCUs (z80, z180, gbz80,
      Rabbit 2000/3000, Rabbit 3000A, TLCS-90), Padauk (pdk14, pdk15)
      and STMicroelectronics STM8. Work is in progress on supporting
      the Padauk (pdk13), Microchip PIC16 and PIC18 targets. It can be
      retargeted for other microprocessors."

  + *GCC for ARM Core/ISA*
    + https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm
    + http://blog.atollic.com/arm-gcc-the-arm-compiler-for-embedded-developers
 
  + *GCC AVR* - Modified GCC for AVR Microcontrollers
    + https://ccrma.stanford.edu/~juanig/articles/wiriavrlib/AVR_GCC.html
    + https://www.nongnu.org/avr-libc/user-manual/overview.html
    + https://blog.podkalicki.com/how-to-compile-and-burn-the-code-to-avr-chip-on-linuxmacosxwindows/
*** Embedded Systems / Pre-built GCC Toolchains
  
   + https://gnutoolchains.com/
    + "This website contains pre-built GNU toolchains for many embedded
       platforms. Every toolchain includes: GNU Binutils;  GCC compiler
       for C and C++ languages; GDB debugger; A port of libc or a
       similar library (e.g. newlib)" 

   + ARM Core
     + https://gnutoolchains.com/arm-eabi/

   + Beagle Bone ARM Development Board (SBC - Single Board Computer)
     + https://gnutoolchains.com/beaglebone/

   + Raspberry Pi - SBC Single Board Computer
     + https://gnutoolchains.com/raspberry/

   + ESP32 
     + https://gnutoolchains.com/esp32/

   + AVR Microcontrollers
     + https://gnutoolchains.com/avr/

** General

 * Documentation Builder, aka Generator 
   + Doxygen => http://www.doxygen.org/
   
 * IDEs and Quasi-IDEs

   + *Visual Studio Community Edition* (Windows Only)

   + *CLion* / JetBrains 

   + GNome Builder => Not an IDE, but at least the code completion
     "just works" without any configuration. 
     + https://wiki.gnome.org/Apps/Builder/Features
     + https://www.collabora.com/news-and-blog/blog/2018/08/03/cross-compilation-made-easy-for-gnome-builder/

 * Building Systems
   + CMake
     + https://cmake.org/documentation/
   + Meson
     + https://github.com/mesonbuild/meson/wiki
   + SCons
     + https://scons.org/
   + Make (GNU Make, BSD Make or Windows MAKE - NMake)
     + https://en.wikipedia.org/wiki/Makefile
   + Ninja
     + https://ninja-build.org/

 * Package Managers:
   + https://conan.io/
   + [[https://docs.microsoft.com/en-us/cpp/vcpkg?view=vs-2017][vcpkg-- A C++ package manager for Windows, Linux and MacOS | Microsoft Docs]]
   + [[http://www.buckaroo.pm/][Buckaroo - C/C++ Package Manager]]
   + [[https://gist.github.com/Overdrivr/d14e4c7e79234f1fb7b3a5a14f8b6ad9][Why C/C++ package managers fail for now ?]]

 * *Debuggers* - Essential tools for development, debugging,
   introspecing processes, reversing engineering and security
   research.
   + GDB  - GNU Debugger 
   + LLDB - LLVM/Clang Debugger
   + WinDG -> Windows Debugger 
   + IDA

** Static code analysers                                     :quality:qa:bug:

Tools for performing static analysis in the code and catching bugs
easily go unnoticed.

   * *Cppcheck*
     + "Cppcheck is a static analysis tool for C/C++ code. It provides
       unique code analysis to detect bugs and focuses on detecting
       undefined behaviour and dangerous coding constructs. The goal is
       to detect only real errors in the code (i.e. have very few false
       positives)."
     + Web Site: http://cppcheck.sourceforge.net/

   * *Clang Analyser*
     + "The Clang Static Analyzer is a source code analysis tool that
       finds bugs in C, C++, and Objective-C programs. Currently it can
       be run either as a standalone tool or within Xcode. The
       standalone tool is invoked from the command line, and is intended
       to be run in tandem with a build of a codebase. The analyzer is
       100% open source and is part of the Clang project. Like the rest
       of Clang, the analyzer is implemented as a C++ library that can
       be used by other tools and applications."
     + Web Site: https://clang-analyzer.llvm.org

   * *Splint - Annotation-Assisted Lightweight Static Checking*
     + "Splint is a tool for statically checking C programs for _security_
       _vulnerabilities_ and coding mistakes. With minimal effort, Splint
       can be used as a better lint. If additional effort is invested
       adding annotations to programs, Splint can perform stronger
       checking than can be done by any standard lint."
     + Web Site: https://splint.org

   * *OCLint*
     + "OCLint is a static code analysis tool for improving quality and
       reducing defects by inspecting C, C++ and Objective-C code and
       looking for potential problems like: Possible bugs - empty
       if/else/try/catch/finally statements; Unused code - unused local
       variables and parameters; Complicated code - high cyclomatic
       complexity, NPath complexity and high NCSS; Redundant code -
       redundant if statement and useless parentheses; Code smells -
       long method and long parameter list; Bad practices - inverted
       logic and parameter reassignment"

   * *PVS-Studio* [PROFESSIONAL TOOL]
     * "PVS-Studio is a tool for detecting bugs and security
       weaknesses in the source code of programs, written in C, C++,
       C# and Java. It works under 64-bit systems in Windows, Linux
       and macOS environments, and can analyze source code intended
       for 32-bit, 64-bit and embedded ARM platforms."

     * In any high stakes or mission critical project, such as
       embedded systems or device drivers, it is worth using tools
       which detect bugs at early stages and avoid hours of debugging
       and frustration. In the case of critical embedded systems, bugs
       can be dangerous and expensive, specially in automotive and
       medical systems.

     * Web site: https://www.viva64.com/en/pvs-studio/

     * Presentation:
       * [[https://www.slideshare.net/Andrey_Karpov/pvsstudio-static-code-analyzer-windowslinux-ccc-2017][PVS-Studio. Static code analyzer. Windows/Linux, C/C++/C#. 2017]]

     * Facilities for enforcing embedded systems code standards:
       + [[https://www.viva64.com/en/m/0045/][PVS-Studio for Embedded Development]]
       + [[https://www.viva64.com/en/b/0596/][PVS-Studio: Support of MISRA C and MISRA C++ Coding Standards]]
       + [[https://medium.com/pvs-studio/using-pvs-studio-static-analyzer-in-c-and-c-development-for-embedded-systems-e1ee1387d931][Using PVS-Studio Static Analyzer in C and C++ Development for Embedded Systems]]

     * Undefined behavior detection: Undefined behavior may cause
       latent bugs and security vulnerabilities which are not easier
       to detect and compilers do not even issue a compile-time
       error or warning. 
       * [[https://www.viva64.com/en/t/0066/][Undefined behavior]]
       * [[https://www.viva64.com/en/b/0374/][Undefined behavior is closer than you think]]

     * More:
       * [[https://www.viva64.com/en/b/0652/][Getting Started with the PVS-Studio Static Analyzer for C++ Development under Linux]]

** Sanitizers 

   + [[https://github.com/google/sanitizers][google/sanitizers]]
     + "This project is the home for Sanitizers: AddressSanitizer,
       MemorySanitizer, ThreadSanitizer, LeakSanitizer, and more The
       actual code resides in the LLVM repository. Here we keep extended
       documentation, bugs and some helper code."

   + [[https://github.com/google/sanitizers/wiki/AddressSanitizer][AddressSanitizer]] - AddressSanitizer (aka ASan) is a memory error detector for C/C++.

   + [[https://github.com/google/sanitizers/wiki/MemorySanitizer][MemorySanitizer]]

   + [[https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html][HWASAN]]

   + [[https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html][UBSAN]] - Undefined Behavior Sanitizer

See also: 

  + Presentation: [[https://www.slideshare.net/sermp/sanitizer-cppcon-russia?qid=406186aa-97a9-4ab1-8fea-644e58cd8a79&v=&b=&from_search=4][Address/Thread/Memory Sanitizer Slaughtering C++ Bugs]] 

** Debuggers 
*** General 

  + [[https://rr-project.org/][rr-project]] - Reverse Debugging
    + "rr aspires to be your primary C/C++ debugging tool for Linux,
      replacing — well, enhancing — gdb. You record a failure once,
      then debug the recording, deterministically, as many times as
      you want. The same execution is replayed every time. rr also
      provides efficient reverse execution under gdb. Set breakpoints
      and data watchpoints and quickly reverse-execute to where they
      were hit. rr works on real applications and is used by many
      developers to fix real bugs. It makes debugging hard bugs much
      easier, but also speeds up debugging of easy bugs."
    + rr features:
      + Low overhead compared to other similar tools, especially on
        mostly-single-threaded workloads
      + Supports recording and replay of all kinds of applications:
        Firefox, Chrome, QEMU, LibreOffice, Go programs, ...
      + Record, replay and debug multiple-process workloads, including
        entire containers
      + Works with gdb scripting and IDE integration
      + Durable, compact traces that can be ported between machines
      + Chaos mode to make intermittent bugs more reproducible 

*** User interfaces for GDB or LLDB 

   + [[https://cgdb.github.io/][CGDB]] - Curses-style termninal user interface for GDB
     + "cgdb is a lightweight curses (terminal-based) interface to the
       GNU Debugger (GDB). In addition to the standard gdb console, cgdb
       provides a split screen view that displays the source code as it
       executes. The keyboard interface is modeled after vim, so vim
       users should feel at home using cgdb."

   + [[https://github.com/cs01/gdbgui/][GdbGUI]] - Brower GUI user interface - it opens a webpage at
     localhost containing a front-end for GDB.
     + Supports commands: YES
     + Video: [[https://www.youtube.com/watch?v=Cd0BOOdGjrw][gdbgui demonstration - browser based gdb frontend]]

   + [[https://wiki.gnome.org/Apps/Nemiver/Features][Nemiver]]
     + [[https://people.gnome.org/~dodji/vids/variable-tooltip.ogg][Screencast]]
     + Supports commands: NO. 

   + [[https://www.gnu.org/software/ddd/][DDD - Data Display Debugger]]
     + Supports commands: YES.
     + [[https://www.gnu.org/software/ddd/manual/html_mono/ddd.html#Summary][Manual]]
     + Video: [[https://www.youtube.com/watch?v=cKQ1qdo79As][GDNU DDD - Software Debugging]]

   + Eclipse CDT IDE
     + Video: [[https://www.youtube.com/watch?v=KbN1UyybsV4][GDB Remote Debugging using LUbuntu Linux and Eclipse CDT Neon 3]]
     + Video: [[https://www.youtube.com/watch?v=T9yFyWsyyGk][Debian C/C++ Cross-Compilation for Embedded Linux using Eclipse (Luna), CDT, RSE & Remote Debug]]

   + [[https://www.youtube.com/watch?v=wUZyoAnPdCY][JetBrain CLion IDE]]  

   + [[https://www.youtube.com/watch?v=-3toI8L3Oug][Microsft Visual Studio]] - (Visual Stdio Debugger can connect from
     Windows to a GDB server remotely over the network)

   + Emacs
     + Supports commands: YES.
     + Video: [[https://youtu.be/Vn1kDWVxq4s?t=344][AoD_1: Debugging with GDB in Emacs]] 

   + More info, see: [[https://sourceware.org/gdb/wiki/GDB%20Front%20Ends][GDB Front Ends - GDB Wiki]] 
*** Memory Leak Debuggers                                    :quality:qa:bug:

 + [[http://www.valgrind.org/][Valgrind]]
   + Most well known memory leak debugger for *Nix
     systems. Unfortunately, it doesn't work on Windows.
   + [[https://en.wikipedia.org/wiki/Valgrind][Valgrind - Wikipedia]]
   + [[http://doc.qt.io/qtcreator/creator-valgrind-overview.html][Using Valgrind Code Analysis Tools | Qt Creator Manual]]

 + [[http://drmemory.org/][Dr. Memory Memory Debugger for Windows and Linux]]
   + "Dr. Memory is a memory monitoring tool capable of identifying
     memory-related programming errors such as accesses of
     uninitialized memory, accesses to unaddressable memory (including
     outside of allocated heap units and heap underflow and overflow),
     accesses to freed memory, double frees, memory leaks, and (on
     Windows) handle leaks, GDI API usage errors, and accesses to
     un-reserved thread local storage slots." 

See also: 
 + [[https://stackoverflow.com/questions/413477/is-there-a-good-valgrind-substitute-for-windows][c - Is there a good Valgrind substitute for Windows? - Stack Overflow]]

** Profiling Tools - Performance Measurement Tools    :qa:quality:speed:perf:

  * *perf* - Performance Monitoring and Analysis tool for Linux
    * https://developers.redhat.com/blog/2019/04/23/how-to-use-the-linux-perf-tool-to-count-software-events/
    * https://www.tecmint.com/perf-performance-monitoring-and-analysis-tool-for-linux/
    * http://lacasa.uah.edu/portal/Upload/tutorials/perf.tool/PerfTool.pdf
    * https://qqibrow.github.io/CPU-Cache-Effects-and-Linux-Perf/
    * https://www.slideshare.net/brendangregg/kernel-recipes-2017-using-linux-perf-at-netflix

  * *Very Sleepy* - Profile for Microsft Windows OS 
    * http://www.codersnotes.com/sleepy/

  * [[http://valgrind.org/docs/manual/cg-manual.html][cachegrind / valgrind]] - (CPU Caches L1, L2, L3)
    + cache-branch prediction profiler - "Cachegrind simulates how your
      program interacts with a machine's cache hierarchy and
      (optionally) branch predictor. It simulates a machine with
      independent first-level instruction and data caches (I1 and D1),
      backed by a unified second-level cache (L2). This exactly matches
      the configuration of many modern machines."
    + See also:
      + [[https://accu.org/index.php/journals/1886][Valgrind Part 4: Cachegrind and Callgrind]]

  * [[http://valgrind.org/docs/manual/cl-manual.html][callgrind / valgrind]] (Call graph)
    + "Callgrind is a profiling tool that records the call history
      among functions in a program's run as a call-graph. By default,
      the collected data consists of the number of instructions
      executed, their relationship to source lines, the caller/callee
      relationship between functions, and the numbers of such
      calls. Optionally, cache simulation and/or branch prediction
      (similar to Cachegrind) can produce further information about
      the runtime behavior of an application." 

  * [[http://valgrind.org/docs/manual/hg-manual.html][helgrind / valgrind]] (Threads and concurrency)
    * "Helgrind is a Valgrind tool for detecting synchronisation
      errors in C, C++ and Fortran programs that use the POSIX
      pthreads threading primitives. The main abstractions in POSIX
      pthreads are: a set of threads sharing a common address space,
      thread creation, thread joining, thread exit, mutexes (locks),
      condition variables (inter-thread event notifications),
      reader-writer locks, spinlocks, semaphores and
      barriers. Helgrind can detect three classes of errors, which are
      discussed in detail in the next three sections: Misuses of the
      POSIX pthreads API; Potential deadlocks arising from lock
      ordering problems and Data races -- accessing memory without
      adequate locking or synchronisation."

  * [[https://github.com/gperftools/gperftools][gperftools]] - Google's Performance Tools
    * https://gperftools.github.io/gperftools/cpuprofile.html
    * https://github.com/gperftools/gperftools/wiki
    * https://wiki.geany.org/howtos/profiling/gperftools

  * [[https://www.gnu.org/software/cflow/][cflow]] (GNU tool) => "Generate call graphs from C code."

  * [[https://github.com/KDE/heaptrack][KDE/heaptrack]] - "heaptrack - a heap memory profiler for Linux"
    * "Heaptrack traces all memory allocations and annotates these
      events with stack traces. Dedicated analysis tools then allow
      you to interpret the heap memory profile to: find hotspots that
      need to be optimized to reduce the memory footprint of your
      application; find memory leaks, i.e. locations that allocate
      memory which is never deallocated; find allocation hotspots,
      i.e. code locations that trigger a lot of memory allocation
      calls; find temporary allocations, which are allocations that
      are directly followed by their deallocation." 

** Code Navigation and Exploration Tools 

Tools for navigating, exploring and undestanding large and unfamiliar
code bases.

 + [[http://www.doxygen.nl/][Doxygen]] [FREE]
   + Doxygen can generate an html cross reference of an unfamiliar
     code base containing embedded code which allows navigating and
     exploring the code in any web browser. Disadvantage: harder to
     use than proper tools built for this purpose. Another issue is
     that the code must be properly annotated with Doxygen markup
     comments. 

 + [[http://cscope.sourceforge.net/][cscope]] [FREE] 
   + Console code navigation tool. "Allows searching code for: all
     references to a symbol; global definitions; functions called by a
     function; functions calling a function; text string; regular
     expression pattern; a file; files including a file"
   + See:
     * https://en.wikipedia.org/wiki/Cscope
     * [[https://stackoverflow.com/questions/2417556/][CScope like functionality for C using VIM]]
     * [[https://stackoverflow.com/questions/11917923/how-to-use-cscope-for-a-project-which-has-c-cpp-and-h-files][How to use cscope for a project which has .c , .cpp and .h files?]]
     * [[https://www.linux.com/news/using-cscope-and-silentbob-analyze-source-code][Using Cscope and SilentBob to analyze source code]]

 + [[https://ruben2020.github.io/codequery/][codequery]] [FREE]
   + "This is a tool to index, then query or search C, C++, Java,
     Python, Ruby, Go and Javascript source code. It builds upon the
     databases of cscope and Exuberant ctags. It can also work with
     Universal ctags, which is a drop-in replacement for Exuberant
     ctags. The databases of cscope and ctags would be processed by
     the cqmakedb tool to generate the CodeQuery database file. The
     CodeQuery database file can be viewed and queried using the
     codequery GUI tool."
   + Features: "Combines the best of both cscope and ctags; Faster due
     to the use of sqlite for the CodeQuery database; Cross-platform
     GUI tool; Fast auto-completion of search term; Case-insensitive,
     partial keyword search - wildcard search supported * and ?; Exact
     match search; Filter search results by file path; File viewer
     with syntax highlighting, for UTF-8 encoded source files; Ability
     to open viewed file in an external editor or IDE; Visualization
     of function call graph and class inheritance based on search
     term; Visualization graphs can be saved to PNG or Graphviz DOT files"

 + [[https://www.sourcetrail.com/][Source Trail]] [NOW OPEN SOURCE] [BEST]
   + Features: Visual navigation, click-at symbol navigation, class
     diagrams, visual inheritance navigation and so on.
   + Repository:  https://github.com/CoatiSoftware/Sourcetrail
   + Download release at: https://github.com/CoatiSoftware/Sourcetrail/releases

 + [[https://www.cppdepend.com/][CPPDepend]] [COMMERCIAL]
   + Features: Allows visual navigation and querying the code with an SQL-like syntax.


Tools for code indexing and cross-reference database for text editors: 

 + [[https://github.com/drothlis/clang-ctags][clang-ctags]]
   + "Generate tag file for C++ source code, using the clang C++
     compiler's parsing libraries. Unlike other ctags implementations,
     clang-ctags uses a real C++ compiler (clang) to parse source
     files, allowing for more accurate indexing. (C++ is notoriously
     difficult to parse, and other ctags implementations rely on
     heuristics to disambiguate certain constructs.) Unlike other
     implementations, clang-ctags only understands C and C++ source
     files; and because clang-ctags needs to run each source file
     through the C pre-processor, its usage is somewhat more
     complicated than other ctags implementations."

 + [[https://github.com/Andersbakken/rtags][rtags]]
   + "RTags is a client/server application that indexes C/C++ code and
     keeps a persistent file-based database of references,
     declarations, definitions, symbolnames etc. There’s also limited
     support for ObjC/ObjC++. It allows you to find symbols by name
     (including nested class and namespace scope). Most importantly we
     give you proper follow-symbol and find-references support. We
     also have neat little things like rename-symbol, integration with
     clang’s “fixits” (https://clang.llvm.org/diagnostics.html). We
     also integrate with flymake using clang’s vastly superior errors
     and warnings. Since RTags constantly will reindex “dirty” files
     you get live updates of compiler errors and warnings. Since we
     already know how to compile your sources we have a way to quickly
     bring up the preprocessed output of the current source file in a
     buffer."

 + [[https://www.gnu.org/software/global/][GNU Global]]
   + "GNU GLOBAL is a source code tagging system that works the same
     way across diverse environments, such as Emacs editor, Vi editor,
     Less viewer, Bash shell, various web browsers, etc. You can
     locate various objects, such as functions, macros, structs,
     classes, in your source files and move there easily. It is useful
     for hacking on large projects which contain many sub-directories,
     many #ifdef and many main() functions. It is similar to ctags or
     etags, but is different from them in the following two points:
     independence of any editor capability to treat definition and
     reference It runs in UNIX (POSIX) compatible operating system,
     like GNU and BSD." 

** Compilation Database Tools 

  + *BEAR - *Build EAR*
    + https://github.com/rizsotto/Bear
    + "Bear is a tool that generates a compilation database for clang
      tooling. The [[http://clang.llvm.org/docs/JSONCompilationDatabase.html][JSON compilation database]] is used in the clang
      project to provide information on how a single compilation unit
      is processed. With this, it is easy to re-run the compilation
      with alternate programs. One way to get a compilation database
      is to use cmake as the build tool. Passing
      -DCMAKE_EXPORT_COMPILE_COMMANDS=ON to cmake generates the
      compile_commands.json file into the current directory. For
      non-cmake projects, Bear generates the JSON file during the
      build process."
    + See:
      + [[https://www.kdab.com/clang-tidy-part-2-integrate-qmake-and-other-build-systems-using-bear/][KDAB - Clang Tidy, part 2: Integrate qmake and other build systems using Bear]]


  * *CompileDB*
    + https://github.com/nickdiego/compiledb
    + "Tool for generating Clang's JSON Compilation Database file for
      GNU make-based build systems. It's aimed mainly at non-cmake
      (cmake already generates compilation database) large
      codebases. Inspired by projects like YCM-Generator and Bear, but
      faster (mainly with large projects), since in most cases it
      doesn't need a clean build (as the mentioned tools do) to
      generate the compilation database file, to achieve this it uses
      the make options such as -n/--dry-run and -k/--keep-going to
      extract the compile commands. Also, it's more cross-compiling
      friendly than YCM-generator's fake-toolchanin approach."

** Clang/LLVM tools 

 + [[https://lldb.llvm.org/][LLDB Debugger]]
   + "LLDB is a next generation, high-performance debugger. It is
     built as a set of reusable components which highly leverage
     existing libraries in the larger LLVM Project, such as the Clang
     expression parser and LLVM disassembler. LLDB is the default
     debugger in Xcode on macOS and supports debugging C, Objective-C
     and C++ on the desktop and iOS devices and simulator."

 + [[https://clang.llvm.org/extra/clang-tidy/][clang-tidy]] - Automating the formatting of C or C++ code according
   to some style. 
   + "clang-tidy is a clang-based C++ 'linter' tool. Its purpose is to
     provide an extensible framework for diagnosing and fixing typical
     programming errors, like style violations, interface misuse, or
     bugs that can be deduced via static analysis. clang-tidy is
     modular and provides a convenient interface for writing new
     checks."
   + See:
     + https://www.kdab.com/clang-tidy-part-1-modernize-source-code-using-c11c14/
     + https://codeyarns.com/2019/01/28/how-to-use-clang-tidy/

 + [[https://devblogs.microsoft.com/cppblog/exploring-clang-tooling-part-2-examining-the-clang-ast-with-clang-query/][clang-query]]
   + Tool for exploring the Clang AST - Abstract Syntax Tree from a
     C++ code base.
   + See:
     * https://clang.llvm.org/docs/LibASTMatchers.html
     * https://steveire.wordpress.com/2018/11/11/future-developments-in-clang-query/
     * https://eli.thegreenplace.net/2014/07/29/ast-matchers-and-clang-refactoring-tools
     * https://clang.llvm.org/docs/LibASTMatchersReference.html

 + [[https://clang.llvm.org/docs/RefactoringEngine.html][clang-refactor]] - Clang Refactoring engine
   + "This document describes the design of Clang’s refactoring engine
     and provides a couple of examples that show how various
     primitives in the refactoring API can be used to implement
     different refactoring actions. The LibTooling library provides
     several other APIs that are used when developing a refactoring
     action. Refactoring engine can be used to implement local
     refactorings that are initiated using a selection in an editor or
     an IDE. You can combine AST matchers and the refactoring engine
     to implement refactorings that don’t lend themselves well to
     source selection and/or have to query ASTs for some particular
     nodes."

 + [[https://clang.llvm.org/extra/clang-rename.html][clang-rename]]
   + "clang-rename is a C++ refactoring tool. Its purpose is to
     perform efficient renaming actions in large-scale projects such
     as renaming classes, functions, variables, arguments, namespaces
     etc. The tool is in a very early development stage, so you might
     encounter bugs and crashes. Submitting reports with information
     about how to reproduce the issue to the LLVM bugtracker will
     definitely help the project. If you have any ideas or
     suggestions, you might want to put a feature request there."
** Documentation Generator 

 + [[http://www.doxygen.nl/][Doxygen]] 
   + Doxygen builds documentatiuon in many formats including text and
     html by extracting documentation code from comments.
   + Example of documentation generated with Doxygen:
     + https://docs.wxwidgets.org/stable/
     + http://assimp.sourceforge.net/lib_html/index.html
     + [[http://www.wangafu.net/~nickm/libevent-2.1/doxygen/html/dir_db160b4728e6067cf5f9cc14ec42c79d.html][libEvent]]

** Unix/POSIX and Linux Development 
*** Manpages offline doc 

    + [[https://github.com/jeaye/stdman][jeaye/stdman]] - Formatted C++20 stdlib man pages (cppreference).
      + stdman is a tool that parses archived HTML files from
        cppreference and generates groff-formatted manual pages for
        Unix-based systems. The goal is to provide excellent
        formatting for easy readability. stdman has been tested on
        Linux and OS X.

    + [[https://github.com/tldr-pages/tldr][tldr]] - Simplified and community-driven man pages.

    + [[https://github.com/sinclairtarget/um][sinclairtarget/um]] - "um is a command-line utility for creating
      and maintaining your own set of man-like help pages. It is
      available for MacOS (via Homebrew) and Linux (via AUR in Arch,
      otherwise via Linuxbrew)."

*** GNU Tools 

The following tools are not only useful for debugging, diagnosing and
assisting development, they are also useful for reverse engineering. 

Note: 
 + object files: executables and shared libraries (*.so files),
   generally with ELF format.

| Tool / Command            | Description                                                  |
|---------------------------+--------------------------------------------------------------|
| file                      | identify file type by its header bytes                       |
| nm                        | list symbols exported by executables                         |
| c++filt                   | demangles C++ symbols                                        |
| objdump                   | show detailed information about object files                 |
| readlef                   | show information about ELF object files.                     |
| strings                   | show human readable characters in the executable             |
| strip                     | discard symbols                                              |
| ptrace and strace         | trace system calls                                           |
| gdb                       | GNU Debugger                                                 |
| lsof                      | Check which files a process is using                         |
| Directory /etc/proc/<pid> | Allows to check which files and resources a process is using |
|                           |                                                              |
|---------------------------+--------------------------------------------------------------|

Command Line Hexadecimal Visualizer

 + *hexdump*

 + *od* 

GNU Tools

 + *readelf* - View ELF file structure 
   + https://www.linuxjournal.com/article/1060

 + *objdump* - View ELF file object-code (disassembler)
   + https://www.howtoforge.com/linux-objdump-command/

 + *nm* - Show symbols of executable or shared library (dll equivalent, aka shared object).

 + *strace* - Allows tracing process system calls and view files opened
   by process. 
*** Unix self-extracting installers 
 
  + [[https://makeself.io/][makeself]] - "makeself - Make self-extractable archives on
    Unix. makeself.sh is a small shell script that generates a
    self-extractable compressed tar archive from a directory. The
    resulting file appears as a shell script (many of those have a
    .run suffix), and can be launched as is. The archive will then
    uncompress itself to a temporary directory and an optional
    arbitrary command will be executed (for example an installation
    script). This is pretty similar to archives generated with WinZip
    Self-Extractor in the Windows world. Makeself archives also
    include checksums for integrity self-validation (CRC and/or
    MD5/SHA256 checksums)."

*** Mac OSX Only

  + [[https://github.com/auriamg/macdylibbundler][auriamg/macdylibbundler]]
    + "Utility to ease bundling libraries into executables for
      OSX. dylibbundler is a small command-line programs that aims to
      make bundling .dylibs as easy as possible. It automatically
      determines which dylibs are needed by your program, copies these
      libraries inside the app bundle, and fixes both them and the
      executable to be ready for distribution... all this with a
      single command on the teminal! It will also work if your program
      uses plug-ins that have dependencies too." 

*** Other tools 

    + [[https://sourceforge.net/projects/shmcat/][shmcat]] 
      + This is a simple tool that dumps shared memory segments
        (System V and POSIX), files and text. It might be useful when
        you have to debug programs that use shared memory. Dumps
        System V (shmget, shmat API) and POSIX (shm_open...) shared
        memory.

** Tools for Making Portable Linux Binaries

    + [[https://github.com/AppImage/AppImageKit][AppImageKit]]
      + "Using AppImageKit you can package desktop applications as
        AppImages that run on common Linux-based operating systems,
        such as RHEL, CentOS, Ubuntu, Fedora, Debian and
        derivatives. Package desktop applications as AppImages that
        run on common Linux-based operating systems, such as RHEL,
        CentOS, openSUSE, SLED, Ubuntu, Fedora, debian and
        derivatives. Join #AppImage on irc.freenode.net"

    + [[https://github.com/probonopd/linuxdeployqt][linuxdeployqt]] - QT C++ Applications 
      + Makes Linux applications self-contained by copying in the
        libraries and plugins that the application uses, and
        optionally generates an AppImage. Can be used for Qt and other
        applications
      + "This Linux Deployment Tool, linuxdeployqt, takes an
        application as input and makes it self-contained by copying in
        the resources that the application uses (like libraries,
        graphics, and plugins) into a bundle. The resulting bundle can
        be distributed as an AppDir or as an AppImage to users, or can
        be put into cross-distribution packages. It can be used as
        part of the build process to deploy applications written in C,
        C++, and other compiled languages with systems like CMake,
        qmake, and make. When used on Qt-based applications, it can
        bundle a specific minimal subset of Qt required to run the
        application."

    + [[https://github.com/linuxdeploy/linuxdeploy][linuxdeploy]]
      + "appimagetool, the tool creating AppImages, expects
        directories in a specific format that will then be converted
        into the final AppImage. This format is called AppDir. It is
        not very difficult to understand, but creating AppDirs for
        arbitrary applications tends to be a very repetitive
        task. Also, bundling all the dependencies properly can be a
        quite difficult task. It seems like there is a need for tools
        which simplify these tasks. linuxdeploy is designed to be an
        AppDir maintenance tool. It provides extensive functionalities
        to create and bundle AppDirs for applications. It features a
        plugin system that allows for easy bundling of frameworks and
        creating output bundles such as AppImages with little effort." 

    + [[https://phusion.github.io/holy-build-box/][Holy Build Box]] - For command line apps and servers.

      + Note: It only works Linux x86 and x64 and does not work with
        graphical applications with GTk, Qt, SDL or OpenGL. It is only
        intended for headless applications such as servers or
        daemons. 

      + "Holy Build Box is a system for building "portable" binaries
        for Linux: binaries that work on pretty much any Linux
        distribution. This works by providing an easy-to-use,
        isolated, tightly-controlled compilation environment that is
        designed for producing portable binaries. Holy Build Box can
        produce x86 and x86-64 binaries."

      + Holy Build Box is made for developers that fit the following criteria:
        * You want to distribute binaries for your C/C++ applications to end users.
        * There are many people in your userbase with low to medium
          system administration skill, and you want your users to be
          able to easily use your applications, so you want to avoid
          asking them to compile from source. 
        * You are wary of having to invest a disproportionate amount
          of time into building platform-specific packages. You want
          something that works for the majority of your users, without
          having to invest too much time.
        * You want your users to be easily able to use the latest
          versions of your software, so waiting for distributions to
          package your application is not an option. 

    + [[https://github.com/ValveSoftware/steam-runtime][steam-runtime]] - For games (developed by Valve company)
      + Note: It creates a chroot for custom compilation. 
      + "A binary compatible runtime environment for Steam
        applications on Linux. This release of the steam-runtime SDK
        marks a change to a chroot environment used for building
        apps. A chroot environment is a standalone Linux environment
        rooted somewhere in your file system. All processes that run
        within the root run relative to that rooted environment. It is
        possible to install a differently versioned distribution
        within a root, than the native distribution. For example, it
        is possible to install an Ubuntu 12.04 chroot environment on
        an Ubuntu 14.04 system. Tools and utilities for building apps
        can be installed in the root using standard package management
        tools, since from the tool's perspective it is running in a
        native Linux environment. This makes it well suited for an SDK
        environment."

See also: 
 + [[https://sagargv.blogspot.com/2014/09/on-building-portable-linux-binaries.html][Sagar's blog: On building portable Linux binaries]]

** Windows Development Tools 
*** Package managers 
 
  + [[https://chocolatey.org/][chocolatey]] - Command line package manager that can install
    applications and packages from command line. It works in a similar
    fashion to MacOSX's homebrew, it does not store any software, the
    repository just contains recipes for installing the applications.

  + [[https://scoop.sh/][Scoop]] - Similar to chocolatey, but it stores the recipes in Github
    repositories. 

*** Sysinternals suite 

 + *SysInternals* - A collection of debugging tools which allows to
   introspect processes and get informations such as loaded DLLs,
   files opened by a process, network activity and so on.
   + https://docs.microsoft.com/en-us/sysinternals/
   + http://www.sysinternals.com/
   + https://docs.microsoft.com/en-us/sysinternals/downloads/process-utilities

 + *Sysinternals* / dumpbin
   + Show informations Windows native executables and shared
     libraries, specifically about PE32 object code. For instance, it
     can show symbols exported by a DLL, DLLs used by an executable
     and functions imported by the executable from DLLs.

 + *Sysinternals* / procmon
   + Process mionitor

 + *Sysinternals* / procexp
   + Process explorer

 + *Sysinternals* / Winobj
   + WinObj accesses and display information on the NT Object
     Manager's name space
*** Installers and unpackers 

 *Installers* 

Tools for creating installers for Windows applications. 

 + [[https://nsis.sourceforge.io/Main_Page][NSIS]] - "NSIS (Nullsoft Scriptable Install System) is a professional
   open source system to create Windows installers. It is designed to
   be as small and flexible as possible and is therefore very suitable
   for internet distribution. Being a user's first experience with
   your product, a stable and reliable installer is an important
   component of successful software. With NSIS you can create such
   installers that are capable of doing everything that is needed to
   setup your software. NSIS is script-based and allows you to create
   the logic to handle even the most complex installation tasks. Many
   plug-ins and scripts are already available: you can create web
   installers, communicate with Windows and other software components,
   install or update shared components and more."

 + [[http://www.jrsoftware.org/isinfo.php][Inno Setup]] - "Inno Setup is a free installer for Windows programs
   by Jordan Russell and Martijn Laan"
   + Source: https://github.com/jrsoftware/issrc
   + Support for every Windows release since 2006, including: Windows
     10, Windows 10 on ARM, Windows Server 2016, Windows 8.1, Windows
     8, Windows Server 2012, Windows 7, Windows Server 2008 R2,
     Windows Server 2008, and Windows Vista. (No service packs are
     required.)
   + Extensive support for both administrative and non administrative
     installations.
   + Supports creation of a single EXE to install your program for
     easy online distribution. Disk spanning is also supported.

 *Unpackers*

 + [[http://constexpr.org/innoextract/][innoextract]] - "A tool to unpack installers created by Inno Setup."

 + [[https://wiki.gnome.org/msitools][msitools]] - "msitools is a set of programs to inspect and build
   Windows Installer (.MSI) files. It is based on libmsi, a portable
   library to read and write .MSI files. libmsi in turn is a port of
   (and a subset of) Wine's implementation of the Windows Installer."
   + https://gitlab.gnome.org/GNOME/msitools
** Cross compilation tools  

    * *MXE - M Cross Compiling Environment* (Linux/UNIX to Windows)
      + https://mxe.cc 
      + Brief: Cross compiling from Unix-like OSes (Linux, MacOSX or
        BSD) to Windows NT 32/64 bits.
      + "MXE (M cross environment) is a GNU Makefile that compiles a
        cross compiler and cross compiles many free libraries such as
        SDL and Qt. Thus, it provides a nice cross compiling environment
        for various target platforms, which:""
        + is designed to run on any Unix system;
        + builds many free libraries in addition to the cross compiler
        + can also build just a subset of the packages, and automatically builds their dependencies
        + downloads all needed packages and verifies them by their checksums
        + is able to update the version numbers of all packages automatically
        + directly uses source packages, thus ensuring the whole build mechanism is transparent
        + has pre-compiled binaries that can be used in Continuous Integration systems
        + ... ... more

    * *Dockcross* (UNIX to Embedded Systems, Mobile/Android and Windows-Mingw)
      + https://github.com/dockcross/dockcross
      + Brief: Cross compiling toolchains in Docker images for
        Linux-ARM; Android-ARM(32 and 64 bits), Many Linux (portable
        linux binaries with GLIBC forward compatibility), Windows with MinGW.
      + Features:
        + Pre-built and configured toolchains for cross compiling
        + Most images also contain an emulator for the target system.
        + Clean separation of build tools, source code, and build artifacts.
        + Commands in the container are run as the calling user, so
          that any created files have the expected ownership,
          (i.e. not root).
        + Make variables (CC, LD etc) are set to point to the appropriate tools in the container.
        + Recent CMake and ninja are precompiled.
        + Conan.io can be used as a package manager.
        + Toolchain files configured for CMake.
        + Current directory is mounted as the container's workdir, /work.
        + Works with the Docker for Mac and Docker for Windows.

    * *MSVC Docker*
      * https://github.com/paleozogt/MSVCDocker
      * Brief: MSVC via Wine in Docker
      * CI with MSVC is unnecessarily difficult. Can't we just use
        Docker? It turns out we can-- by running MSVC in Wine. Lots of
        folks have tried to do this over the years [1], but the setup
        is involved and fiddly. But scripting complicated setups is
        what Docker was made for! The big blocker to getting MSVC in
        Wine is that even though the software itself works under Wine,
        the installers don't. We dodge that problem by using Vagrant
        to drive the MSVC installer in a real Windows OS within
        VirtualBox, export a snapshot of the installation, and then
        Docker copies the snapshot into Wine. 

** State Machine Code Generators 

State machine are ubiquitous in software for broad range of
application domains such as games, game animations, embedded systems,
network protocols, parsers and so on. The following tools can generate
C and C++ state machine code from graphical user interface or from a
domain specific language.

   + [[http://www.colm.net/open-source/ragel/][Ragel State Machine Compiler]]
     + "Ragel compiles executable finite state machines from regular
       languages. Ragel targets C, C++ and ASM. Ragel state machines can
       not only recognize byte sequences as regular expression machines
       do, but can also execute code at arbitrary points in the
       recognition of a regular language. Code embedding is done using
       inline operators that do not disrupt the regular language
       syntax. The core language consists of standard regular expression
       operators (such as union, concatenation and Kleene star) and
       action embedding operators. The user’s regular expressions are
       compiled to a deterministic state machine and the embedded
       actions are associated with the transitions of the
       machine. Understanding the formal relationship between regular
       expressions and deterministic finite automata is key to using
       Ragel effectively." 

   + [[http://smc.sourceforge.net/][SMC: The State Machine Compiler]]
     + "Now you put your state diagram in one file using an
       easy-to-understand language. SMC generates the state pattern
       classes for you. No more hand-maintained transition matrices. No
       more widely scattered switch statements. Instead, the state
       diagram is in one place, coded directly from the picture to the
       SMC language and is easily maintained. SMC uses the state pattern
       to its fullest extent. In the real world, events don't always
       happen when they should. Dealing with unexpected events is a must
       for a robust application. By combining virtual methods with the
       state pattern, SMC allows you to define "Default" transitions -
       transitions which allow your objects to handle unexpected events,
       recover and continue providing service (rather than crashing,
       burning and getting you into trouble). SMC is a Java
       application. That means SMC will work on any platform where Java
       1.7.0 or better is supported."

   + [[http://www.stateforge.com/][State machine generator & state diagram editor - StateForge]]
     + "State machine code generators: Tranform a state machine
       description into C#, Java or C++ source code. UML semantics:
       hierarchical, concurrent, asynchronous, entry/exit and history
       state. An extended version of state pattern is generated."

   + [[http://yasmine.seadex.de/yasmine.html][yasmine - yasmine - the C++ UML state machine framework]]
     + "yasmine is a C++ state machine framework developed by
       Seadex. The latest stable version is 1.5.3. The very first beta
       version (0.1.0) was released on June 20, 2016. Originally only
       supporting C++11 support for C++03 was added with Beta 6
       (0.6.0). Version 1.0.0, the first stable version, was released
       January 20, 2017. The complete version history is available for
       you, too. yasmine is not just yet another state machine
       framework! It is an easy to use high level UML state machine
       abstraction that nicely integrates with modern object oriented
       C++ code. She is also highly portable. yasmine is in active use
       under Linux and Windows. Hardware platforms she's running on
       include x86, ARM, and Blackfin. Builds are actively tested for
       MSVC, gcc, and Clang."

** Compiler Metadata Generators

 + [[https://pygccxml.readthedocs.io/en/develop/upgrade_issues.html][GCC-XML 0.7 → 0.9 upgrade issues (Legacy) — pygccxml 1.9.1 documentation]]    

** Reverse Engineering and Forensics Tools 
*** Debuggers for reverse engineering debuggers 

 + [[https://github.com/CheckPointSW/scout][scout]] - Scout - Instruction based research debugger
   + "Scout is an extendable basic debugger that was designed for use
     in those cases that there is no built-in debugger / gdb-stub in
     the debugee process / firmware. The debugger is intended to be
     used by security researchers in various scenarios, such as:
     Collecting information on the address space of the debuggee -
     recon phase and exploit development; Exploring functionality of
     the original executable by accessing and executing selected code
     snippets; Adding and testing new functionality using custom
     debugger instructions; We have successfully used "Scout" as a
     debugger in a Linux Kernel setup, and in several embedded
     firmware research projects, and so we believe that it's
     extendable API could prove handy for other security researchers
     in their research projects."

 + [[https://www.hex-rays.com/products/ida/debugger/index.shtml][IDA]] - Interactive Disassemble and debugger designed for reverse
   engineering. In addition Linux, Windows and OSX binaries, IDA can
   also disassemble firmwares.

 + [[http://www.ollydbg.de/][OllyDBG]] (Windows-only) - Debugger designed for reverse engineering
   with better capabilities to operate without debugging symbols.

 + [[https://x64dbg.com/#start][x64dbg]] (Windows-only) -  An open-source x64/x32 debugger for windows.
   + Features: "An open-source binary debugger for Windows, aimed at
     malware analysis and reverse engineering of executables you do
     not have the source code for. There are many features available
     and a comprehensive plugin system to add your own. You can find
     more information on the blog!" 
   + Repository: https://github.com/x64dbg/x64dbg
   + Blogs:
     + https://x64dbg.com/blog/
     + http://reverseengineeringtips.blogspot.com/2015/01/an-introduction-to-x64dbg.html

*** Tools for analysing executable formats PE, ELF, MachO 

   + [[http://hte.sourceforge.net/][hte]] - "Viewer/editor/analyzer for executables"
     + Supported object file formats: common object file format
       (COFF/XCOFF32); executable and linkable format (ELF); linear
       executables (LE); standard dos executables (MZ); new executables
       (NE); portable executables (PE32, PE64); Mach exe/link format
       (MachO); ... ... 
     + https://github.com/sebastianbiallas/ht

   + [[http://pev.sourceforge.net/][pev]]
     + "pev the PE file analysis toolkit fast, scriptable,
       multiplatform, feature-rich, free and open source."

   + [[https://github.com/elboza/dwarf-ng/][dwarf-ng]]
     + "dwarf-ng is a powerful object file manipulation tool and hex
       editor in the spirit of gdb. with dwarf-ng you can read and edit
       all the file's section headers as well as the raw data. With
       dwarf-ng you can create and customize new file's header and it
       can be used as a compiler back-end to create executables/object
       files. dwarf-ng also permits to inject easily new headers and
       pieces of code/data into the file. dwarf-ng currently handles
       Raw ELF (Elf32, Elf64), PE (Portable executables PE32, PE+) and
       Mach-O (os x executables 32&64bit)".

   + [[https://www.prevanders.net/dwarf.html][dwarfutils]]
     + "Dump and produce DWARF debug information in ELF objects."

   + [[https://nixos.org/patchelf.html][patchelf]]
     + "PatchELF is a small utility to modify the dynamic linker and
       RPATH of ELF executables. Dynamically linked ELF executables
       always specify a dynamic linker or interpreter, which is a
       program that actually loads the executable along with all its
       dynamically linked libraries. (The kernel just loads the
       interpreter, not the executable.) For example, on a Linux/x86
       system the ELF interpreter is typically the file
       /lib/ld-linux.so.2. It is sometimes necessary to use a different
       ELF interpreter, say, when you want to test a version of Glibc
       installed in a location other than /lib. And in the Nix Packages
       collection we build our own Glibc, which we obviously want to
       use. Building programs with a different interpreter is a matter
       of using the linker flag -dynamic-linker: ... ..."

   + [[https://sourceforge.net/projects/osslsigncode/][osslsigncode]]
     + "Platform-independent tool for Authenticode signing of
       PE(EXE/SYS/DLL/etc), CAB and MSI files - uses OpenSSL and
       libcurl. It also supports timestamping (Authenticode and
       RFC3161)."
 
*** Firmware Extraction 

  + [[https://github.com/ReFirmLabs/binwalk][binwalk]] - Binwalk is a fast, easy to use tool for analyzing, reverse engineering, and extracting firmware images.
    + "Binwalk is an open source firmware extraction tool that
      extracts embedded file systems from firmware images. Created in
      2010 by ReFirm Lab’s own Principal Reverse Engineer Craig
      Heffner, Binwalk is widely recognized as the leading tool for
      reverse engineering firmware images." 
    + See:
      + https://www.refirmlabs.com/binwalk/
      + [[http://manpages.ubuntu.com/manpages/bionic/en/man1/binwalk.1.html][Ubuntu Manpage: binwalk - tool for searching binary images for embedded files and executable code]]
      + https://github.com/ReFirmLabs/binwalk/wiki
      + [[https://gist.github.com/briankip/8f8747a2488af827e3b4][A short introduction to binwalk]]
      + [[https://eforensicsmag.com/file-system-analysis-with-binwalk/][File System Analysis with Binwalk | By Alex Ocheme Ogbole - eForensics]]

*** Windows NT 

   + *Dependency Walker*
     - Tool which scans executable dependencies such as imported DLLs.
     - http://www.dependencywalker.com/

   + *Resource Hacker*
     - User interface that allows to inspect, extract and modify
       resources of Windows executables (PE32 and PE64).
     - http://www.angusj.com/resourcehacker/

   + *RPC View*
     - "A free and powerful tool to explore and decompile all
       RPCfunctionalities present on a Microsoft system."
     - http://rpcview.org/

   + *API Monitor*
     - "Monitor is a free software that lets you monitor and control
       API  calls made by applications and services. Its a powerful
       tool for  seeing how applications and services work or for
       tracking down problems that you have in your own applications."
     - http://www.rohitab.com/apimonitor

   + *Winapi Override*
     - "WinAPIOverride is an advanced api monitoring software for 32
       and 64 bits processes. You can monitor and/or override any
       function of a process. This can be done for API functions or
       executable internal functions. It tries to fill the gap between
       classical API monitoring softwares and debuggers. It can break
       targeted application before or after a function call, allowing
       memory or registers changes; and it can directly call functions
       of the targeted application."
     - http://jacquelin.potier.free.fr/winapioverride32/

   + *NtTrace* (Strace for Windows)
     - "NtTrace provides a simple trace facility for the Windows
       Native API. It is roughly equivalent to strace on Linux. The
       native API is the interface between the application space and
       the OS kernel; this API is provided by ntdll.dll. It is not
       very well documented, and changes between versions of Windows,
       but tracing execution of an application at this level can
       provide a clear view of its use of the operating
       system. NtTrace uses the debugging interface on Windows to
       intercept the returns from the native API and display the input
       arguments and return code. Return codes are translated to
       Window error code and error messages where possible."
     - http://www.howzatt.demon.co.uk/NtTrace/
     - https://github.com/rogerorr/NtTrace
*** Network Protocols Debugging

Testing socket clients or servers: 

 + [[https://en.wikipedia.org/wiki/Netcat][Netcat, aka nc]]

 + [[http://www.dest-unreach.org/socat/][socat]]
   + https://github.com/craSH/socat
   + [[https://blog.rootshell.be/2010/10/31/socat-another-network-swiss-army-knife/][Socat, Another Network Swiss Army Knife | /dev/random]]

Http Requests: 

  + [[https://curl.haxx.se/][curl]] - Can be used for testing http servers and performing http
    requests from command line simulating a web browser.

  + [[https://httpd.apache.org/docs/2.4/programs/ab.html][ab - Apache HTTP server benchmarking tool]]
    + "ab is a tool for benchmarking your Apache Hypertext Transfer
      Protocol (HTTP) server. It is designed to give you an impression
      of how your current Apache installation performs. This
      especially shows you how many requests per second your Apache
      installation is capable of serving."
    + See: 
      + [[https://blog.getpolymorph.com/7-tips-for-heavy-load-testing-with-apache-bench-b1127916b7b6][7 Tips for Heavy Load Testing with Apache Bench - Polymorph Blog]]
      + [[https://www.digitalocean.com/community/tutorials/how-to-use-apachebench-to-do-load-testing-on-an-ubuntu-13-10-vps][How To Use ApacheBench To Do Load Testing on an Ubuntu 13.10 VPS | DigitalOcean]]
      + [[https://wiki.xandr.com/display/documentation/How+to+Apache+Stress+Test+With+ab+Tool][How to Apache Stress Test With ab Tool - Cloud Services - Xandr Documentation]]

  + [[https://mitmproxy.org/][mitmproxy]] - mitmproxy is a free and open source interactive HTTPS
    proxy. 
    + https://github.com/mitmproxy/mitmproxy

Websockets: 

  + [[https://github.com/joewalnes/websocketd][joewalnes/websocketd]]
    + "Turn any program that uses STDIN/STDOUT into a WebSocket
      server. Like inetd, but for WebSockets. http://websocketd.com/" 

  + [[https://github.com/websockets/wscat][wscat]]
    + "WebSocket cat" 

Network capture and packet inspection, low level analysis: 

  + [[https://www.wireshark.org/][wireshark]]
    + "Wireshark is the world’s foremost and widely-used network
      protocol analyzer. It lets you see what’s happening on your
      network at a microscopic level and is the de facto (and often de
      jure) standard across many commercial and non-profit
      enterprises, government agencies, and educational
      institutions. Wireshark development thrives thanks to the
      volunteer contributions of networking experts around the globe
      and is the continuation of a project started by Gerald Combs in
      1998."

  + [[https://www.tcpdump.org/][tcpdump]]
    + "tcpdump, a powerful command-line packet analyzer; and libpcap,
      a portable C/C++ library for network traffic capture."

  + [[https://github.com/simsong/tcpflow][tcpflow]]
    + "tcpflow is a program that captures data transmitted as part of
      TCP connections (flows), and stores the data in a way that is
      convenient for protocol analysis and debugging. Each TCP flow is
      stored in its own file. Thus, the typical TCP flow will be
      stored in two files, one for each direction. tcpflow can also
      process stored 'tcpdump' packet flows."
    + See: [[https://www.tecmint.com/tcpflow-analyze-debug-network-traffic-in-linux/][TCPflow - Analyze and Debug Network Traffic in Linux]]

Certificates SSL/TSL: 

  + [[https://github.com/FiloSottile/mkcert][mkcert]] - "mkcert is a simple tool for making locally-trusted
    development certificates. It requires no configuration." 

  + [[https://github.com/jsha/minica][minica]] - "minica is a small, simple CA intended for use in
    situations where the CA operator also operates each host where a
    certificate will be used."

  + [[https://github.com/square/certigo][certigo]] - "Certigo is a utility to examine and validate
    certificates to help with debugging SSL/TLS issues. Supports all
    common file formats: Certigo can read and dump certificates in
    various formats. It can automatically detect and read from X.509
    (DER/PEM), JCEKS, PKCS7 and PKCS12 files. Certificates can be
    dumped to a human-readable format, a set of PEM blocks, or a JSON
    object for use in scripting." 
*** Framework and Toolboxes 

  + [[https://www.radare.org/r/][radare]] Framework - A suite of reversing enegineering tools.
    + Features:
      * Disassemble (and assemble for) many different architectures
      * Debug with local native and remote debuggers (gdb, rap, webui, r2pipe, winedbg, windbg)
      * Run on Linux, *BSD, Windows, OSX, Android, iOS, Solaris and Haiku
      * Perform forensics on filesystems and data carving
      * Be scripted in Python, Javascript, Go and more
      * Support collaborative analysis using the embedded webserver
      * Visualize data structures of several file types
      * Patch programs to uncover new features or fix vulnerabilities
      * Use powerful analysis capabilities to speed up reversing
      * Aid in software exploitation

  + [[https://github.com/ps1337/radare2-docker][radare2-docker]] - Dockerized version of Radare2.

  + [[https://github.com/mxmssh/drltrace][mxmssh/drltrace]] - Drltrace is a library calls tracer for Windows and Linux applications.
    + "Drltrace is a dynamic API calls tracer for Windows and Linux
      applications. Drltrace is built on top of DynamoRIO dynamic
      binary instrumentation framework. Drltrace was initialy
      implemented by Derek Bruening and distributed with DynamoRIO and
      DrMemory frameworks. This repository contains a standalone
      version of drltrace with additional scripts and materials on how
      to use it for malware analysis. The release build can be
      downloaded here."

  + [[https://frida.re/][Frida]] - Dynamic instrumentation toolkit for developers,
    reverse-engineers, and security researchers. Features:
    * "Scriptable: Inject your own scripts into black box
      processes. Hook any function, spy on crypto APIs or trace
      private application code, no source code needed. Edit, hit save,
      and instantly see the results. All without compilation steps or
      program restarts."
    * "Portable: Works on Windows, macOS, GNU/Linux, iOS, Android, and
      QNX. Install the Node.js bindings from npm, grab a Python
      package from PyPI, or use Frida through its Swift bindings, .NET
      bindings, Qt/Qml bindings, or C API." 
*** Misc 

  + https://godbolt.org/
    + Compiler explorer - allows to explore the assembly generated by a
      wide variety of compilers, including, GNU GCC, Clang, MSVC and so
      on.

  + [[https://github.com/zerosum0x0/WinREPL][WinREPL]] - Assembly REPL - interactive shell like Python or IPython
    for Windows.
    + Precompile binaries: https://github.com/zerosum0x0/WinREPL/releases/

  + [[https://github.com/yrp604/rappel][Rappel]] - A linux-based assembly REPL for x86, amd64, armv7, and armv8.
    + [[https://news.ycombinator.com/item?id=11214868][Rappel: A REPL for x86, amd64, and armv7 | Hacker News]]

  + [[http://www.unicorn-engine.org/][Unicorn]] - CPU emulator Framework
    + https://github.com/unicorn-engine/unicorn  

** Fonts For Programming 

  + [[https://github.com/smallwat3r/droid-sans-mono-sw][droid-sans-mono-sw]]
    * "Custom version of the font "Droid Sans Mono", improved for
      Programming. Some characters have been modified which makes it
      easier to code. (Including parenthesis size, dotted zero, At
      sign, Dollar, Tilde, comma/semicolon/dot sizes and a few other
      characters)."

  + [[https://github.com/ProgrammingFonts/ProgrammingFonts][ProgrammingFonts]]
    * "This is a collection of programming fonts,just share this with
      the programmers.Now there are 33 kinds of fantastic fonts!
      http://www.programmingfonts.com." 

** Emacs as a C++ IDE 

Misc: 

 + [[https://nilsdeppe.com/posts/emacs-c++-ide2][Using Emacs as a C++ IDE - Take 2]]
 + [[http://martinsosic.com/development/emacs/2017/12/09/emacs-cpp-ide.html][Emacs as a C++ IDE]]
 + [[https://oremacs.com/2017/03/28/emacs-cpp-ide/][Using Emacs as a C++ IDE · (or emacs]]
 + [[https://tuhdo.github.io/c-ide.html][C/C++ Development Environment for Emacs]]
 + [[https://www.reddit.com/r/emacs/comments/7wzstc/emacs_as_a_c_ide_martin_sosics_blog/][Emacs as a C++ IDE - Martin Sosic's blog : emacs]]

Using Emacs a GDB Front-end (aka user interface): 

 + [[https://www.cs.bu.edu/teaching/tool/emacs/programming/][Using
   Emacs for Programming]]   

